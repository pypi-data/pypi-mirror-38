Metadata-Version: 2.1
Name: unpythonic
Version: 0.11.1
Summary: Lispy (and some haskelly) missing batteries for Python.
Home-page: https://github.com/Technologicat/unpythonic
Author: Juha Jeronen
Author-email: juha.jeronen@tut.fi
License: BSD
Keywords: functional-programming,syntactic-macros,macros,lisp,scheme,racket,haskell
Platform: Linux
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Provides: unpythonic

We provide missing features for Python, mainly from the list processing
tradition, but with some haskellisms mixed in. We place a special emphasis on
**clear, pythonic syntax**. For the adventurous, we also provide a set of
syntactic macros that are designed to work together.

Design considerations are simplicity, robustness, and minimal dependencies
(currently none required; MacroPy optional, to enable the syntactic macros).
In macros we aim at orthogonality, combinability, and clear, pythonic syntax.

Features include tail call optimization (TCO), TCO'd loops in FP style, call/ec,
let & letrec, assign-once, multi-expression lambdas, def as a code block,
dynamic assignment, memoize (also for generators and iterables), compose,
folds and scans (left and right), unfold, lazy partial unpacking of iterables,
functional sequence updates, pythonic lispy linked lists.

We provide a curry that passes extra arguments through on the right, and calls
a callable return value on the remaining arguments. This is now valid Python::

    mymap = lambda f: curry(foldr, composerc(cons, f), nil)
    myadd = lambda a, b: a + b
    assert curry(mymap, myadd, ll(1, 2, 3), ll(2, 4, 6)) == ll(3, 6, 9)

    with_n = lambda *args: (partial(f, n) for n, f in args)
    look = lambda n1, n2: composel(*with_n((n1, drop), (n2, take)))
    assert tuple(curry(look, 5, 10, range(20))) == tuple(range(5, 15))

As macros we provide e.g. automatic currying, automatic tail-call optimization,
continuations (``call/cc``), lexically scoped ``let`` and ``do``, implicit
return statements, and easy-to-use multi-expression lambdas with local variables.

For a taste of the macros::

    # let, letseq, letrec with no boilerplate
    a = let((x, 17),
            (y, 23))[
              (x, y)]

    # cond: multi-branch "if" expression
    answer = lambda x: cond[x == 2, "two",
                            x == 3, "three",
                            "something else"]
    assert answer(42) == "something else"

    # do: imperative code in expression position
    y = do[local(x << 17),
           print(x),
           x << 23,
           x]
    assert y == 23

    # autocurry like Haskell
    with curry:
        def add3(a, b, c):
            return a + b + c
        assert add3(1)(2)(3) == 6
        # actually partial application so these work, too
        assert add3(1, 2)(3) == 6
        assert add3(1)(2, 3) == 6
        assert add3(1, 2, 3) == 6

        mymap = lambda f: foldr(composerc(cons, f), nil)
        myadd = lambda a, b: a + b
        assert mymap(myadd, ll(1, 2, 3), ll(2, 4, 6)) == ll(3, 6, 9)

    # automatic tail-call optimization (TCO) like Scheme, Racket
    with tco:
        assert letrec((evenp, lambda x: (x == 0) or oddp(x - 1)),
                      (oddp,  lambda x: (x != 0) and evenp(x - 1)))[
                        evenp(10000)] is True

    # lambdas with multiple expressions, local variables, and a name
    with multilambda, namedlambda:
        myadd = lambda x, y: [print("myadding", x, y),
                              local(tmp << x + y),
                              print("result is", tmp),
                              tmp]
        assert myadd(2, 3) == 5
        assert myadd.__name__ == "myadd (lambda)"

    # implicit "return" in tail position, like Lisps
    with autoreturn:
        def f():
            print("hi")
            "I'll just return this"
        assert f() == "I'll just return this"

        def g(x):
            if x == 1:
                "one"
            elif x == 2:
                "two"
            else:
                "something else"
        assert g(1) == "one"
        assert g(2) == "two"
        assert g(42) == "something else"

    # splice code at macro expansion time
    with let_syntax:
        with block(a) as twice:
            a
            a
        with block(x, y, z) as appendxyz:
            lst += [x, y, z]
        lst = []
        twice(appendxyz(7, 8, 9))
        assert lst == [7, 8, 9]*2

    # lispy prefix syntax for function calls
    with prefix:
        (print, "hello world")

    # the LisThEll programming language
    with prefix, curry:
        mymap = lambda f: (foldr, (compose, cons, f), nil)
        double = lambda x: 2 * x
        (print, (mymap, double, (q, 1, 2, 3)))
        assert (mymap, double, (q, 1, 2, 3)) == ll(2, 4, 6)

    # essentially call/cc for Python
    with continuations:
        stack = []
        def amb(lst, *, cc):  # McCarthy's amb operator
            if not lst:
                return fail()
            first, *rest = lst
            if rest:
                ourcc = cc
                stack.append(lambda *, cc: amb(rest, cc=ourcc))
            return first
        def fail(*, cc):
            if stack:
                f = stack.pop()
                return f()

        def pyth(*, cc):
            with bind[amb(tuple(range(1, 21)))] as z:
                with bind[amb(tuple(range(1, z+1)))] as y:
                    with bind[amb(tuple(range(1, y+1)))] as x:  # <-- the call/cc
                        if x*x + y*y != z*z:                    # body is the cont
                            return fail()
                        return x, y, z
        x = pyth()
        while x:
            print(x)
            x = fail()

For documentation and full examples, see the project's GitHub homepage.


