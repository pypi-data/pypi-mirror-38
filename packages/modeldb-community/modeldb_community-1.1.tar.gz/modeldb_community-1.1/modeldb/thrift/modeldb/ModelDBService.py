#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport


class Iface(object):
    def testConnection(self):
        pass

    def storeDataFrame(self, df, experimentRunId):
        """
        Parameters:
         - df
         - experimentRunId
        """
        pass

    def pathForTransformer(self, transformerId):
        """
        Parameters:
         - transformerId
        """
        pass

    def storeFitEvent(self, fe):
        """
        Parameters:
         - fe
        """
        pass

    def storeMetricEvent(self, me):
        """
        Parameters:
         - me
        """
        pass

    def getFilePath(self, t, experimentRunId, filename):
        """
        Parameters:
         - t
         - experimentRunId
         - filename
        """
        pass

    def storeTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        pass

    def storeRandomSplitEvent(self, rse):
        """
        Parameters:
         - rse
        """
        pass

    def storePipelineEvent(self, pipelineEvent):
        """
        Parameters:
         - pipelineEvent
        """
        pass

    def storeCrossValidationEvent(self, cve):
        """
        Parameters:
         - cve
        """
        pass

    def storeGridSearchCrossValidationEvent(self, gscve):
        """
        Parameters:
         - gscve
        """
        pass

    def storeAnnotationEvent(self, ae):
        """
        Parameters:
         - ae
        """
        pass

    def storeProjectEvent(self, pr):
        """
        Parameters:
         - pr
        """
        pass

    def storeExperimentEvent(self, er):
        """
        Parameters:
         - er
        """
        pass

    def storeExperimentRunEvent(self, er):
        """
        Parameters:
         - er
        """
        pass

    def storeLinearModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        pass

    def getDataFrameAncestry(self, dataFrameId):
        """
        Parameters:
         - dataFrameId
        """
        pass

    def getCommonAncestor(self, dfId1, dfId2):
        """
        Parameters:
         - dfId1
         - dfId2
        """
        pass

    def getCommonAncestorForModels(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def getTrainingRowsCount(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def getTrainingRowsCounts(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        pass

    def compareHyperparameters(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def compareFeatures(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        pass

    def groupByProblemType(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        pass

    def similarModels(self, modelId, compMetrics, numModels):
        """
        Parameters:
         - modelId
         - compMetrics
         - numModels
        """
        pass

    def linearModelFeatureImportances(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def compareLinearModelFeatureImportances(self, model1Id, model2Id):
        """
        Parameters:
         - model1Id
         - model2Id
        """
        pass

    def iterationsUntilConvergence(self, modelIds, tolerance):
        """
        Parameters:
         - modelIds
         - tolerance
        """
        pass

    def rankModels(self, modelIds, metric):
        """
        Parameters:
         - modelIds
         - metric
        """
        pass

    def confidenceIntervals(self, modelId, sigLevel):
        """
        Parameters:
         - modelId
         - sigLevel
        """
        pass

    def modelsWithFeatures(self, featureNames):
        """
        Parameters:
         - featureNames
        """
        pass

    def modelsDerivedFromDataFrame(self, dfId):
        """
        Parameters:
         - dfId
        """
        pass

    def getProjectIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        pass

    def getModelIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        pass

    def updateProject(self, projectId, key, value):
        """
        Parameters:
         - projectId
         - key
         - value
        """
        pass

    def createOrUpdateScalarField(self, modelId, key, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - value
         - valueType
        """
        pass

    def createVectorField(self, modelId, vectorName, vectorConfig):
        """
        Parameters:
         - modelId
         - vectorName
         - vectorConfig
        """
        pass

    def updateVectorField(self, modelId, key, valueIndex, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - valueIndex
         - value
         - valueType
        """
        pass

    def appendToVectorField(self, modelId, vectorName, value, valueType):
        """
        Parameters:
         - modelId
         - vectorName
         - value
         - valueType
        """
        pass

    def getModel(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def getRunsInExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        pass

    def getRunsAndExperimentsInProject(self, projId):
        """
        Parameters:
         - projId
        """
        pass

    def getProjectOverviews(self):
        pass

    def getExperimentRunDetails(self, experimentRunId):
        """
        Parameters:
         - experimentRunId
        """
        pass

    def originalFeatures(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def storeTreeModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        pass

    def storePipelineTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        pass

    def computeModelAncestry(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass

    def extractPipeline(self, modelId):
        """
        Parameters:
         - modelId
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def testConnection(self):
        self.send_testConnection()
        return self.recv_testConnection()

    def send_testConnection(self):
        self._oprot.writeMessageBegin('testConnection', TMessageType.CALL, self._seqid)
        args = testConnection_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testConnection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testConnection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testConnection failed: unknown result")

    def storeDataFrame(self, df, experimentRunId):
        """
        Parameters:
         - df
         - experimentRunId
        """
        self.send_storeDataFrame(df, experimentRunId)
        return self.recv_storeDataFrame()

    def send_storeDataFrame(self, df, experimentRunId):
        self._oprot.writeMessageBegin('storeDataFrame', TMessageType.CALL, self._seqid)
        args = storeDataFrame_args()
        args.df = df
        args.experimentRunId = experimentRunId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeDataFrame(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeDataFrame_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeDataFrame failed: unknown result")

    def pathForTransformer(self, transformerId):
        """
        Parameters:
         - transformerId
        """
        self.send_pathForTransformer(transformerId)
        return self.recv_pathForTransformer()

    def send_pathForTransformer(self, transformerId):
        self._oprot.writeMessageBegin('pathForTransformer', TMessageType.CALL, self._seqid)
        args = pathForTransformer_args()
        args.transformerId = transformerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pathForTransformer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pathForTransformer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.efEx is not None:
            raise result.efEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pathForTransformer failed: unknown result")

    def storeFitEvent(self, fe):
        """
        Parameters:
         - fe
        """
        self.send_storeFitEvent(fe)
        return self.recv_storeFitEvent()

    def send_storeFitEvent(self, fe):
        self._oprot.writeMessageBegin('storeFitEvent', TMessageType.CALL, self._seqid)
        args = storeFitEvent_args()
        args.fe = fe
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeFitEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeFitEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeFitEvent failed: unknown result")

    def storeMetricEvent(self, me):
        """
        Parameters:
         - me
        """
        self.send_storeMetricEvent(me)
        return self.recv_storeMetricEvent()

    def send_storeMetricEvent(self, me):
        self._oprot.writeMessageBegin('storeMetricEvent', TMessageType.CALL, self._seqid)
        args = storeMetricEvent_args()
        args.me = me
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeMetricEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeMetricEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeMetricEvent failed: unknown result")

    def getFilePath(self, t, experimentRunId, filename):
        """
        Parameters:
         - t
         - experimentRunId
         - filename
        """
        self.send_getFilePath(t, experimentRunId, filename)
        return self.recv_getFilePath()

    def send_getFilePath(self, t, experimentRunId, filename):
        self._oprot.writeMessageBegin('getFilePath', TMessageType.CALL, self._seqid)
        args = getFilePath_args()
        args.t = t
        args.experimentRunId = experimentRunId
        args.filename = filename
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFilePath(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFilePath_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilePath failed: unknown result")

    def storeTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        self.send_storeTransformEvent(te)
        return self.recv_storeTransformEvent()

    def send_storeTransformEvent(self, te):
        self._oprot.writeMessageBegin('storeTransformEvent', TMessageType.CALL, self._seqid)
        args = storeTransformEvent_args()
        args.te = te
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeTransformEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeTransformEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeTransformEvent failed: unknown result")

    def storeRandomSplitEvent(self, rse):
        """
        Parameters:
         - rse
        """
        self.send_storeRandomSplitEvent(rse)
        return self.recv_storeRandomSplitEvent()

    def send_storeRandomSplitEvent(self, rse):
        self._oprot.writeMessageBegin('storeRandomSplitEvent', TMessageType.CALL, self._seqid)
        args = storeRandomSplitEvent_args()
        args.rse = rse
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeRandomSplitEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeRandomSplitEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeRandomSplitEvent failed: unknown result")

    def storePipelineEvent(self, pipelineEvent):
        """
        Parameters:
         - pipelineEvent
        """
        self.send_storePipelineEvent(pipelineEvent)
        return self.recv_storePipelineEvent()

    def send_storePipelineEvent(self, pipelineEvent):
        self._oprot.writeMessageBegin('storePipelineEvent', TMessageType.CALL, self._seqid)
        args = storePipelineEvent_args()
        args.pipelineEvent = pipelineEvent
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storePipelineEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storePipelineEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storePipelineEvent failed: unknown result")

    def storeCrossValidationEvent(self, cve):
        """
        Parameters:
         - cve
        """
        self.send_storeCrossValidationEvent(cve)
        return self.recv_storeCrossValidationEvent()

    def send_storeCrossValidationEvent(self, cve):
        self._oprot.writeMessageBegin('storeCrossValidationEvent', TMessageType.CALL, self._seqid)
        args = storeCrossValidationEvent_args()
        args.cve = cve
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeCrossValidationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeCrossValidationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeCrossValidationEvent failed: unknown result")

    def storeGridSearchCrossValidationEvent(self, gscve):
        """
        Parameters:
         - gscve
        """
        self.send_storeGridSearchCrossValidationEvent(gscve)
        return self.recv_storeGridSearchCrossValidationEvent()

    def send_storeGridSearchCrossValidationEvent(self, gscve):
        self._oprot.writeMessageBegin('storeGridSearchCrossValidationEvent', TMessageType.CALL, self._seqid)
        args = storeGridSearchCrossValidationEvent_args()
        args.gscve = gscve
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeGridSearchCrossValidationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeGridSearchCrossValidationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeGridSearchCrossValidationEvent failed: unknown result")

    def storeAnnotationEvent(self, ae):
        """
        Parameters:
         - ae
        """
        self.send_storeAnnotationEvent(ae)
        return self.recv_storeAnnotationEvent()

    def send_storeAnnotationEvent(self, ae):
        self._oprot.writeMessageBegin('storeAnnotationEvent', TMessageType.CALL, self._seqid)
        args = storeAnnotationEvent_args()
        args.ae = ae
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeAnnotationEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeAnnotationEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeAnnotationEvent failed: unknown result")

    def storeProjectEvent(self, pr):
        """
        Parameters:
         - pr
        """
        self.send_storeProjectEvent(pr)
        return self.recv_storeProjectEvent()

    def send_storeProjectEvent(self, pr):
        self._oprot.writeMessageBegin('storeProjectEvent', TMessageType.CALL, self._seqid)
        args = storeProjectEvent_args()
        args.pr = pr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeProjectEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeProjectEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeProjectEvent failed: unknown result")

    def storeExperimentEvent(self, er):
        """
        Parameters:
         - er
        """
        self.send_storeExperimentEvent(er)
        return self.recv_storeExperimentEvent()

    def send_storeExperimentEvent(self, er):
        self._oprot.writeMessageBegin('storeExperimentEvent', TMessageType.CALL, self._seqid)
        args = storeExperimentEvent_args()
        args.er = er
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeExperimentEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeExperimentEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentEvent failed: unknown result")

    def storeExperimentRunEvent(self, er):
        """
        Parameters:
         - er
        """
        self.send_storeExperimentRunEvent(er)
        return self.recv_storeExperimentRunEvent()

    def send_storeExperimentRunEvent(self, er):
        self._oprot.writeMessageBegin('storeExperimentRunEvent', TMessageType.CALL, self._seqid)
        args = storeExperimentRunEvent_args()
        args.er = er
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeExperimentRunEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeExperimentRunEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentRunEvent failed: unknown result")

    def storeLinearModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        self.send_storeLinearModel(modelId, model)
        return self.recv_storeLinearModel()

    def send_storeLinearModel(self, modelId, model):
        self._oprot.writeMessageBegin('storeLinearModel', TMessageType.CALL, self._seqid)
        args = storeLinearModel_args()
        args.modelId = modelId
        args.model = model
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeLinearModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeLinearModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeLinearModel failed: unknown result")

    def getDataFrameAncestry(self, dataFrameId):
        """
        Parameters:
         - dataFrameId
        """
        self.send_getDataFrameAncestry(dataFrameId)
        return self.recv_getDataFrameAncestry()

    def send_getDataFrameAncestry(self, dataFrameId):
        self._oprot.writeMessageBegin('getDataFrameAncestry', TMessageType.CALL, self._seqid)
        args = getDataFrameAncestry_args()
        args.dataFrameId = dataFrameId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDataFrameAncestry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDataFrameAncestry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataFrameAncestry failed: unknown result")

    def getCommonAncestor(self, dfId1, dfId2):
        """
        Parameters:
         - dfId1
         - dfId2
        """
        self.send_getCommonAncestor(dfId1, dfId2)
        return self.recv_getCommonAncestor()

    def send_getCommonAncestor(self, dfId1, dfId2):
        self._oprot.writeMessageBegin('getCommonAncestor', TMessageType.CALL, self._seqid)
        args = getCommonAncestor_args()
        args.dfId1 = dfId1
        args.dfId2 = dfId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonAncestor(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonAncestor_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestor failed: unknown result")

    def getCommonAncestorForModels(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_getCommonAncestorForModels(modelId1, modelId2)
        return self.recv_getCommonAncestorForModels()

    def send_getCommonAncestorForModels(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('getCommonAncestorForModels', TMessageType.CALL, self._seqid)
        args = getCommonAncestorForModels_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonAncestorForModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonAncestorForModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestorForModels failed: unknown result")

    def getTrainingRowsCount(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_getTrainingRowsCount(modelId)
        return self.recv_getTrainingRowsCount()

    def send_getTrainingRowsCount(self, modelId):
        self._oprot.writeMessageBegin('getTrainingRowsCount', TMessageType.CALL, self._seqid)
        args = getTrainingRowsCount_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTrainingRowsCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTrainingRowsCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCount failed: unknown result")

    def getTrainingRowsCounts(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        self.send_getTrainingRowsCounts(modelIds)
        return self.recv_getTrainingRowsCounts()

    def send_getTrainingRowsCounts(self, modelIds):
        self._oprot.writeMessageBegin('getTrainingRowsCounts', TMessageType.CALL, self._seqid)
        args = getTrainingRowsCounts_args()
        args.modelIds = modelIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTrainingRowsCounts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTrainingRowsCounts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCounts failed: unknown result")

    def compareHyperparameters(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_compareHyperparameters(modelId1, modelId2)
        return self.recv_compareHyperparameters()

    def send_compareHyperparameters(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('compareHyperparameters', TMessageType.CALL, self._seqid)
        args = compareHyperparameters_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareHyperparameters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareHyperparameters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareHyperparameters failed: unknown result")

    def compareFeatures(self, modelId1, modelId2):
        """
        Parameters:
         - modelId1
         - modelId2
        """
        self.send_compareFeatures(modelId1, modelId2)
        return self.recv_compareFeatures()

    def send_compareFeatures(self, modelId1, modelId2):
        self._oprot.writeMessageBegin('compareFeatures', TMessageType.CALL, self._seqid)
        args = compareFeatures_args()
        args.modelId1 = modelId1
        args.modelId2 = modelId2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareFeatures failed: unknown result")

    def groupByProblemType(self, modelIds):
        """
        Parameters:
         - modelIds
        """
        self.send_groupByProblemType(modelIds)
        return self.recv_groupByProblemType()

    def send_groupByProblemType(self, modelIds):
        self._oprot.writeMessageBegin('groupByProblemType', TMessageType.CALL, self._seqid)
        args = groupByProblemType_args()
        args.modelIds = modelIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_groupByProblemType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = groupByProblemType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "groupByProblemType failed: unknown result")

    def similarModels(self, modelId, compMetrics, numModels):
        """
        Parameters:
         - modelId
         - compMetrics
         - numModels
        """
        self.send_similarModels(modelId, compMetrics, numModels)
        return self.recv_similarModels()

    def send_similarModels(self, modelId, compMetrics, numModels):
        self._oprot.writeMessageBegin('similarModels', TMessageType.CALL, self._seqid)
        args = similarModels_args()
        args.modelId = modelId
        args.compMetrics = compMetrics
        args.numModels = numModels
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_similarModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = similarModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.brEx is not None:
            raise result.brEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "similarModels failed: unknown result")

    def linearModelFeatureImportances(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_linearModelFeatureImportances(modelId)
        return self.recv_linearModelFeatureImportances()

    def send_linearModelFeatureImportances(self, modelId):
        self._oprot.writeMessageBegin('linearModelFeatureImportances', TMessageType.CALL, self._seqid)
        args = linearModelFeatureImportances_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_linearModelFeatureImportances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = linearModelFeatureImportances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "linearModelFeatureImportances failed: unknown result")

    def compareLinearModelFeatureImportances(self, model1Id, model2Id):
        """
        Parameters:
         - model1Id
         - model2Id
        """
        self.send_compareLinearModelFeatureImportances(model1Id, model2Id)
        return self.recv_compareLinearModelFeatureImportances()

    def send_compareLinearModelFeatureImportances(self, model1Id, model2Id):
        self._oprot.writeMessageBegin('compareLinearModelFeatureImportances', TMessageType.CALL, self._seqid)
        args = compareLinearModelFeatureImportances_args()
        args.model1Id = model1Id
        args.model2Id = model2Id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compareLinearModelFeatureImportances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compareLinearModelFeatureImportances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "compareLinearModelFeatureImportances failed: unknown result")

    def iterationsUntilConvergence(self, modelIds, tolerance):
        """
        Parameters:
         - modelIds
         - tolerance
        """
        self.send_iterationsUntilConvergence(modelIds, tolerance)
        return self.recv_iterationsUntilConvergence()

    def send_iterationsUntilConvergence(self, modelIds, tolerance):
        self._oprot.writeMessageBegin('iterationsUntilConvergence', TMessageType.CALL, self._seqid)
        args = iterationsUntilConvergence_args()
        args.modelIds = modelIds
        args.tolerance = tolerance
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_iterationsUntilConvergence(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = iterationsUntilConvergence_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "iterationsUntilConvergence failed: unknown result")

    def rankModels(self, modelIds, metric):
        """
        Parameters:
         - modelIds
         - metric
        """
        self.send_rankModels(modelIds, metric)
        return self.recv_rankModels()

    def send_rankModels(self, modelIds, metric):
        self._oprot.writeMessageBegin('rankModels', TMessageType.CALL, self._seqid)
        args = rankModels_args()
        args.modelIds = modelIds
        args.metric = metric
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rankModels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rankModels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rankModels failed: unknown result")

    def confidenceIntervals(self, modelId, sigLevel):
        """
        Parameters:
         - modelId
         - sigLevel
        """
        self.send_confidenceIntervals(modelId, sigLevel)
        return self.recv_confidenceIntervals()

    def send_confidenceIntervals(self, modelId, sigLevel):
        self._oprot.writeMessageBegin('confidenceIntervals', TMessageType.CALL, self._seqid)
        args = confidenceIntervals_args()
        args.modelId = modelId
        args.sigLevel = sigLevel
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_confidenceIntervals(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = confidenceIntervals_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.ioEx is not None:
            raise result.ioEx
        if result.brEx is not None:
            raise result.brEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "confidenceIntervals failed: unknown result")

    def modelsWithFeatures(self, featureNames):
        """
        Parameters:
         - featureNames
        """
        self.send_modelsWithFeatures(featureNames)
        return self.recv_modelsWithFeatures()

    def send_modelsWithFeatures(self, featureNames):
        self._oprot.writeMessageBegin('modelsWithFeatures', TMessageType.CALL, self._seqid)
        args = modelsWithFeatures_args()
        args.featureNames = featureNames
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modelsWithFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modelsWithFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsWithFeatures failed: unknown result")

    def modelsDerivedFromDataFrame(self, dfId):
        """
        Parameters:
         - dfId
        """
        self.send_modelsDerivedFromDataFrame(dfId)
        return self.recv_modelsDerivedFromDataFrame()

    def send_modelsDerivedFromDataFrame(self, dfId):
        self._oprot.writeMessageBegin('modelsDerivedFromDataFrame', TMessageType.CALL, self._seqid)
        args = modelsDerivedFromDataFrame_args()
        args.dfId = dfId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modelsDerivedFromDataFrame(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modelsDerivedFromDataFrame_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsDerivedFromDataFrame failed: unknown result")

    def getProjectIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        self.send_getProjectIds(keyValuePairs)
        return self.recv_getProjectIds()

    def send_getProjectIds(self, keyValuePairs):
        self._oprot.writeMessageBegin('getProjectIds', TMessageType.CALL, self._seqid)
        args = getProjectIds_args()
        args.keyValuePairs = keyValuePairs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProjectIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProjectIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProjectIds failed: unknown result")

    def getModelIds(self, keyValuePairs):
        """
        Parameters:
         - keyValuePairs
        """
        self.send_getModelIds(keyValuePairs)
        return self.recv_getModelIds()

    def send_getModelIds(self, keyValuePairs):
        self._oprot.writeMessageBegin('getModelIds', TMessageType.CALL, self._seqid)
        args = getModelIds_args()
        args.keyValuePairs = keyValuePairs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModelIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModelIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModelIds failed: unknown result")

    def updateProject(self, projectId, key, value):
        """
        Parameters:
         - projectId
         - key
         - value
        """
        self.send_updateProject(projectId, key, value)
        return self.recv_updateProject()

    def send_updateProject(self, projectId, key, value):
        self._oprot.writeMessageBegin('updateProject', TMessageType.CALL, self._seqid)
        args = updateProject_args()
        args.projectId = projectId
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateProject failed: unknown result")

    def createOrUpdateScalarField(self, modelId, key, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - value
         - valueType
        """
        self.send_createOrUpdateScalarField(modelId, key, value, valueType)
        return self.recv_createOrUpdateScalarField()

    def send_createOrUpdateScalarField(self, modelId, key, value, valueType):
        self._oprot.writeMessageBegin('createOrUpdateScalarField', TMessageType.CALL, self._seqid)
        args = createOrUpdateScalarField_args()
        args.modelId = modelId
        args.key = key
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createOrUpdateScalarField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createOrUpdateScalarField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createOrUpdateScalarField failed: unknown result")

    def createVectorField(self, modelId, vectorName, vectorConfig):
        """
        Parameters:
         - modelId
         - vectorName
         - vectorConfig
        """
        self.send_createVectorField(modelId, vectorName, vectorConfig)
        return self.recv_createVectorField()

    def send_createVectorField(self, modelId, vectorName, vectorConfig):
        self._oprot.writeMessageBegin('createVectorField', TMessageType.CALL, self._seqid)
        args = createVectorField_args()
        args.modelId = modelId
        args.vectorName = vectorName
        args.vectorConfig = vectorConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createVectorField failed: unknown result")

    def updateVectorField(self, modelId, key, valueIndex, value, valueType):
        """
        Parameters:
         - modelId
         - key
         - valueIndex
         - value
         - valueType
        """
        self.send_updateVectorField(modelId, key, valueIndex, value, valueType)
        return self.recv_updateVectorField()

    def send_updateVectorField(self, modelId, key, valueIndex, value, valueType):
        self._oprot.writeMessageBegin('updateVectorField', TMessageType.CALL, self._seqid)
        args = updateVectorField_args()
        args.modelId = modelId
        args.key = key
        args.valueIndex = valueIndex
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateVectorField failed: unknown result")

    def appendToVectorField(self, modelId, vectorName, value, valueType):
        """
        Parameters:
         - modelId
         - vectorName
         - value
         - valueType
        """
        self.send_appendToVectorField(modelId, vectorName, value, valueType)
        return self.recv_appendToVectorField()

    def send_appendToVectorField(self, modelId, vectorName, value, valueType):
        self._oprot.writeMessageBegin('appendToVectorField', TMessageType.CALL, self._seqid)
        args = appendToVectorField_args()
        args.modelId = modelId
        args.vectorName = vectorName
        args.value = value
        args.valueType = valueType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_appendToVectorField(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = appendToVectorField_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "appendToVectorField failed: unknown result")

    def getModel(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_getModel(modelId)
        return self.recv_getModel()

    def send_getModel(self, modelId):
        self._oprot.writeMessageBegin('getModel', TMessageType.CALL, self._seqid)
        args = getModel_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getModel failed: unknown result")

    def getRunsInExperiment(self, experimentId):
        """
        Parameters:
         - experimentId
        """
        self.send_getRunsInExperiment(experimentId)
        return self.recv_getRunsInExperiment()

    def send_getRunsInExperiment(self, experimentId):
        self._oprot.writeMessageBegin('getRunsInExperiment', TMessageType.CALL, self._seqid)
        args = getRunsInExperiment_args()
        args.experimentId = experimentId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunsInExperiment(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunsInExperiment_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunsInExperiment failed: unknown result")

    def getRunsAndExperimentsInProject(self, projId):
        """
        Parameters:
         - projId
        """
        self.send_getRunsAndExperimentsInProject(projId)
        return self.recv_getRunsAndExperimentsInProject()

    def send_getRunsAndExperimentsInProject(self, projId):
        self._oprot.writeMessageBegin('getRunsAndExperimentsInProject', TMessageType.CALL, self._seqid)
        args = getRunsAndExperimentsInProject_args()
        args.projId = projId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRunsAndExperimentsInProject(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRunsAndExperimentsInProject_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRunsAndExperimentsInProject failed: unknown result")

    def getProjectOverviews(self):
        self.send_getProjectOverviews()
        return self.recv_getProjectOverviews()

    def send_getProjectOverviews(self):
        self._oprot.writeMessageBegin('getProjectOverviews', TMessageType.CALL, self._seqid)
        args = getProjectOverviews_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProjectOverviews(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProjectOverviews_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProjectOverviews failed: unknown result")

    def getExperimentRunDetails(self, experimentRunId):
        """
        Parameters:
         - experimentRunId
        """
        self.send_getExperimentRunDetails(experimentRunId)
        return self.recv_getExperimentRunDetails()

    def send_getExperimentRunDetails(self, experimentRunId):
        self._oprot.writeMessageBegin('getExperimentRunDetails', TMessageType.CALL, self._seqid)
        args = getExperimentRunDetails_args()
        args.experimentRunId = experimentRunId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getExperimentRunDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getExperimentRunDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.svEx is not None:
            raise result.svEx
        if result.rnfEx is not None:
            raise result.rnfEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getExperimentRunDetails failed: unknown result")

    def originalFeatures(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_originalFeatures(modelId)
        return self.recv_originalFeatures()

    def send_originalFeatures(self, modelId):
        self._oprot.writeMessageBegin('originalFeatures', TMessageType.CALL, self._seqid)
        args = originalFeatures_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_originalFeatures(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = originalFeatures_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "originalFeatures failed: unknown result")

    def storeTreeModel(self, modelId, model):
        """
        Parameters:
         - modelId
         - model
        """
        self.send_storeTreeModel(modelId, model)
        return self.recv_storeTreeModel()

    def send_storeTreeModel(self, modelId, model):
        self._oprot.writeMessageBegin('storeTreeModel', TMessageType.CALL, self._seqid)
        args = storeTreeModel_args()
        args.modelId = modelId
        args.model = model
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storeTreeModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storeTreeModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storeTreeModel failed: unknown result")

    def storePipelineTransformEvent(self, te):
        """
        Parameters:
         - te
        """
        self.send_storePipelineTransformEvent(te)
        return self.recv_storePipelineTransformEvent()

    def send_storePipelineTransformEvent(self, te):
        self._oprot.writeMessageBegin('storePipelineTransformEvent', TMessageType.CALL, self._seqid)
        args = storePipelineTransformEvent_args()
        args.te = te
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_storePipelineTransformEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = storePipelineTransformEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ierEx is not None:
            raise result.ierEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "storePipelineTransformEvent failed: unknown result")

    def computeModelAncestry(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_computeModelAncestry(modelId)
        return self.recv_computeModelAncestry()

    def send_computeModelAncestry(self, modelId):
        self._oprot.writeMessageBegin('computeModelAncestry', TMessageType.CALL, self._seqid)
        args = computeModelAncestry_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_computeModelAncestry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = computeModelAncestry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "computeModelAncestry failed: unknown result")

    def extractPipeline(self, modelId):
        """
        Parameters:
         - modelId
        """
        self.send_extractPipeline(modelId)
        return self.recv_extractPipeline()

    def send_extractPipeline(self, modelId):
        self._oprot.writeMessageBegin('extractPipeline', TMessageType.CALL, self._seqid)
        args = extractPipeline_args()
        args.modelId = modelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_extractPipeline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = extractPipeline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.rnfEx is not None:
            raise result.rnfEx
        if result.svEx is not None:
            raise result.svEx
        raise TApplicationException(TApplicationException.MISSING_RESULT, "extractPipeline failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["testConnection"] = Processor.process_testConnection
        self._processMap["storeDataFrame"] = Processor.process_storeDataFrame
        self._processMap["pathForTransformer"] = Processor.process_pathForTransformer
        self._processMap["storeFitEvent"] = Processor.process_storeFitEvent
        self._processMap["storeMetricEvent"] = Processor.process_storeMetricEvent
        self._processMap["getFilePath"] = Processor.process_getFilePath
        self._processMap["storeTransformEvent"] = Processor.process_storeTransformEvent
        self._processMap["storeRandomSplitEvent"] = Processor.process_storeRandomSplitEvent
        self._processMap["storePipelineEvent"] = Processor.process_storePipelineEvent
        self._processMap["storeCrossValidationEvent"] = Processor.process_storeCrossValidationEvent
        self._processMap["storeGridSearchCrossValidationEvent"] = Processor.process_storeGridSearchCrossValidationEvent
        self._processMap["storeAnnotationEvent"] = Processor.process_storeAnnotationEvent
        self._processMap["storeProjectEvent"] = Processor.process_storeProjectEvent
        self._processMap["storeExperimentEvent"] = Processor.process_storeExperimentEvent
        self._processMap["storeExperimentRunEvent"] = Processor.process_storeExperimentRunEvent
        self._processMap["storeLinearModel"] = Processor.process_storeLinearModel
        self._processMap["getDataFrameAncestry"] = Processor.process_getDataFrameAncestry
        self._processMap["getCommonAncestor"] = Processor.process_getCommonAncestor
        self._processMap["getCommonAncestorForModels"] = Processor.process_getCommonAncestorForModels
        self._processMap["getTrainingRowsCount"] = Processor.process_getTrainingRowsCount
        self._processMap["getTrainingRowsCounts"] = Processor.process_getTrainingRowsCounts
        self._processMap["compareHyperparameters"] = Processor.process_compareHyperparameters
        self._processMap["compareFeatures"] = Processor.process_compareFeatures
        self._processMap["groupByProblemType"] = Processor.process_groupByProblemType
        self._processMap["similarModels"] = Processor.process_similarModels
        self._processMap["linearModelFeatureImportances"] = Processor.process_linearModelFeatureImportances
        self._processMap["compareLinearModelFeatureImportances"] = Processor.process_compareLinearModelFeatureImportances
        self._processMap["iterationsUntilConvergence"] = Processor.process_iterationsUntilConvergence
        self._processMap["rankModels"] = Processor.process_rankModels
        self._processMap["confidenceIntervals"] = Processor.process_confidenceIntervals
        self._processMap["modelsWithFeatures"] = Processor.process_modelsWithFeatures
        self._processMap["modelsDerivedFromDataFrame"] = Processor.process_modelsDerivedFromDataFrame
        self._processMap["getProjectIds"] = Processor.process_getProjectIds
        self._processMap["getModelIds"] = Processor.process_getModelIds
        self._processMap["updateProject"] = Processor.process_updateProject
        self._processMap["createOrUpdateScalarField"] = Processor.process_createOrUpdateScalarField
        self._processMap["createVectorField"] = Processor.process_createVectorField
        self._processMap["updateVectorField"] = Processor.process_updateVectorField
        self._processMap["appendToVectorField"] = Processor.process_appendToVectorField
        self._processMap["getModel"] = Processor.process_getModel
        self._processMap["getRunsInExperiment"] = Processor.process_getRunsInExperiment
        self._processMap["getRunsAndExperimentsInProject"] = Processor.process_getRunsAndExperimentsInProject
        self._processMap["getProjectOverviews"] = Processor.process_getProjectOverviews
        self._processMap["getExperimentRunDetails"] = Processor.process_getExperimentRunDetails
        self._processMap["originalFeatures"] = Processor.process_originalFeatures
        self._processMap["storeTreeModel"] = Processor.process_storeTreeModel
        self._processMap["storePipelineTransformEvent"] = Processor.process_storePipelineTransformEvent
        self._processMap["computeModelAncestry"] = Processor.process_computeModelAncestry
        self._processMap["extractPipeline"] = Processor.process_extractPipeline

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_testConnection(self, seqid, iprot, oprot):
        args = testConnection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testConnection_result()
        try:
            result.success = self._handler.testConnection()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testConnection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeDataFrame(self, seqid, iprot, oprot):
        args = storeDataFrame_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeDataFrame_result()
        try:
            result.success = self._handler.storeDataFrame(args.df, args.experimentRunId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeDataFrame", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pathForTransformer(self, seqid, iprot, oprot):
        args = pathForTransformer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pathForTransformer_result()
        try:
            result.success = self._handler.pathForTransformer(args.transformerId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except InvalidFieldException as efEx:
            msg_type = TMessageType.REPLY
            result.efEx = efEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pathForTransformer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeFitEvent(self, seqid, iprot, oprot):
        args = storeFitEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeFitEvent_result()
        try:
            result.success = self._handler.storeFitEvent(args.fe)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeFitEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeMetricEvent(self, seqid, iprot, oprot):
        args = storeMetricEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeMetricEvent_result()
        try:
            result.success = self._handler.storeMetricEvent(args.me)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeMetricEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFilePath(self, seqid, iprot, oprot):
        args = getFilePath_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFilePath_result()
        try:
            result.success = self._handler.getFilePath(args.t, args.experimentRunId, args.filename)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFilePath", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeTransformEvent(self, seqid, iprot, oprot):
        args = storeTransformEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeTransformEvent_result()
        try:
            result.success = self._handler.storeTransformEvent(args.te)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeTransformEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeRandomSplitEvent(self, seqid, iprot, oprot):
        args = storeRandomSplitEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeRandomSplitEvent_result()
        try:
            result.success = self._handler.storeRandomSplitEvent(args.rse)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeRandomSplitEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storePipelineEvent(self, seqid, iprot, oprot):
        args = storePipelineEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storePipelineEvent_result()
        try:
            result.success = self._handler.storePipelineEvent(args.pipelineEvent)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storePipelineEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeCrossValidationEvent(self, seqid, iprot, oprot):
        args = storeCrossValidationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeCrossValidationEvent_result()
        try:
            result.success = self._handler.storeCrossValidationEvent(args.cve)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeCrossValidationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeGridSearchCrossValidationEvent(self, seqid, iprot, oprot):
        args = storeGridSearchCrossValidationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeGridSearchCrossValidationEvent_result()
        try:
            result.success = self._handler.storeGridSearchCrossValidationEvent(args.gscve)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeGridSearchCrossValidationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeAnnotationEvent(self, seqid, iprot, oprot):
        args = storeAnnotationEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeAnnotationEvent_result()
        try:
            result.success = self._handler.storeAnnotationEvent(args.ae)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeAnnotationEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeProjectEvent(self, seqid, iprot, oprot):
        args = storeProjectEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeProjectEvent_result()
        try:
            result.success = self._handler.storeProjectEvent(args.pr)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeProjectEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeExperimentEvent(self, seqid, iprot, oprot):
        args = storeExperimentEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeExperimentEvent_result()
        try:
            result.success = self._handler.storeExperimentEvent(args.er)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeExperimentEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeExperimentRunEvent(self, seqid, iprot, oprot):
        args = storeExperimentRunEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeExperimentRunEvent_result()
        try:
            result.success = self._handler.storeExperimentRunEvent(args.er)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeExperimentRunEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeLinearModel(self, seqid, iprot, oprot):
        args = storeLinearModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeLinearModel_result()
        try:
            result.success = self._handler.storeLinearModel(args.modelId, args.model)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeLinearModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDataFrameAncestry(self, seqid, iprot, oprot):
        args = getDataFrameAncestry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDataFrameAncestry_result()
        try:
            result.success = self._handler.getDataFrameAncestry(args.dataFrameId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDataFrameAncestry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonAncestor(self, seqid, iprot, oprot):
        args = getCommonAncestor_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonAncestor_result()
        try:
            result.success = self._handler.getCommonAncestor(args.dfId1, args.dfId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonAncestor", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonAncestorForModels(self, seqid, iprot, oprot):
        args = getCommonAncestorForModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonAncestorForModels_result()
        try:
            result.success = self._handler.getCommonAncestorForModels(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonAncestorForModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTrainingRowsCount(self, seqid, iprot, oprot):
        args = getTrainingRowsCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTrainingRowsCount_result()
        try:
            result.success = self._handler.getTrainingRowsCount(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTrainingRowsCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTrainingRowsCounts(self, seqid, iprot, oprot):
        args = getTrainingRowsCounts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTrainingRowsCounts_result()
        try:
            result.success = self._handler.getTrainingRowsCounts(args.modelIds)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTrainingRowsCounts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareHyperparameters(self, seqid, iprot, oprot):
        args = compareHyperparameters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareHyperparameters_result()
        try:
            result.success = self._handler.compareHyperparameters(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareHyperparameters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareFeatures(self, seqid, iprot, oprot):
        args = compareFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareFeatures_result()
        try:
            result.success = self._handler.compareFeatures(args.modelId1, args.modelId2)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_groupByProblemType(self, seqid, iprot, oprot):
        args = groupByProblemType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = groupByProblemType_result()
        try:
            result.success = self._handler.groupByProblemType(args.modelIds)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("groupByProblemType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_similarModels(self, seqid, iprot, oprot):
        args = similarModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = similarModels_result()
        try:
            result.success = self._handler.similarModels(args.modelId, args.compMetrics, args.numModels)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except BadRequestException as brEx:
            msg_type = TMessageType.REPLY
            result.brEx = brEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("similarModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_linearModelFeatureImportances(self, seqid, iprot, oprot):
        args = linearModelFeatureImportances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = linearModelFeatureImportances_result()
        try:
            result.success = self._handler.linearModelFeatureImportances(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("linearModelFeatureImportances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compareLinearModelFeatureImportances(self, seqid, iprot, oprot):
        args = compareLinearModelFeatureImportances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compareLinearModelFeatureImportances_result()
        try:
            result.success = self._handler.compareLinearModelFeatureImportances(args.model1Id, args.model2Id)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compareLinearModelFeatureImportances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_iterationsUntilConvergence(self, seqid, iprot, oprot):
        args = iterationsUntilConvergence_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = iterationsUntilConvergence_result()
        try:
            result.success = self._handler.iterationsUntilConvergence(args.modelIds, args.tolerance)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("iterationsUntilConvergence", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rankModels(self, seqid, iprot, oprot):
        args = rankModels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rankModels_result()
        try:
            result.success = self._handler.rankModels(args.modelIds, args.metric)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rankModels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_confidenceIntervals(self, seqid, iprot, oprot):
        args = confidenceIntervals_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = confidenceIntervals_result()
        try:
            result.success = self._handler.confidenceIntervals(args.modelId, args.sigLevel)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except IllegalOperationException as ioEx:
            msg_type = TMessageType.REPLY
            result.ioEx = ioEx
        except BadRequestException as brEx:
            msg_type = TMessageType.REPLY
            result.brEx = brEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("confidenceIntervals", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modelsWithFeatures(self, seqid, iprot, oprot):
        args = modelsWithFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modelsWithFeatures_result()
        try:
            result.success = self._handler.modelsWithFeatures(args.featureNames)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modelsWithFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modelsDerivedFromDataFrame(self, seqid, iprot, oprot):
        args = modelsDerivedFromDataFrame_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modelsDerivedFromDataFrame_result()
        try:
            result.success = self._handler.modelsDerivedFromDataFrame(args.dfId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modelsDerivedFromDataFrame", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProjectIds(self, seqid, iprot, oprot):
        args = getProjectIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProjectIds_result()
        try:
            result.success = self._handler.getProjectIds(args.keyValuePairs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProjectIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModelIds(self, seqid, iprot, oprot):
        args = getModelIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModelIds_result()
        try:
            result.success = self._handler.getModelIds(args.keyValuePairs)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModelIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateProject(self, seqid, iprot, oprot):
        args = updateProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProject_result()
        try:
            result.success = self._handler.updateProject(args.projectId, args.key, args.value)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createOrUpdateScalarField(self, seqid, iprot, oprot):
        args = createOrUpdateScalarField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createOrUpdateScalarField_result()
        try:
            result.success = self._handler.createOrUpdateScalarField(args.modelId, args.key, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createOrUpdateScalarField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createVectorField(self, seqid, iprot, oprot):
        args = createVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createVectorField_result()
        try:
            result.success = self._handler.createVectorField(args.modelId, args.vectorName, args.vectorConfig)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateVectorField(self, seqid, iprot, oprot):
        args = updateVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateVectorField_result()
        try:
            result.success = self._handler.updateVectorField(args.modelId, args.key, args.valueIndex, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_appendToVectorField(self, seqid, iprot, oprot):
        args = appendToVectorField_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = appendToVectorField_result()
        try:
            result.success = self._handler.appendToVectorField(args.modelId, args.vectorName, args.value, args.valueType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("appendToVectorField", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getModel(self, seqid, iprot, oprot):
        args = getModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getModel_result()
        try:
            result.success = self._handler.getModel(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunsInExperiment(self, seqid, iprot, oprot):
        args = getRunsInExperiment_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunsInExperiment_result()
        try:
            result.success = self._handler.getRunsInExperiment(args.experimentId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunsInExperiment", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRunsAndExperimentsInProject(self, seqid, iprot, oprot):
        args = getRunsAndExperimentsInProject_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRunsAndExperimentsInProject_result()
        try:
            result.success = self._handler.getRunsAndExperimentsInProject(args.projId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRunsAndExperimentsInProject", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProjectOverviews(self, seqid, iprot, oprot):
        args = getProjectOverviews_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProjectOverviews_result()
        try:
            result.success = self._handler.getProjectOverviews()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProjectOverviews", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getExperimentRunDetails(self, seqid, iprot, oprot):
        args = getExperimentRunDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getExperimentRunDetails_result()
        try:
            result.success = self._handler.getExperimentRunDetails(args.experimentRunId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getExperimentRunDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_originalFeatures(self, seqid, iprot, oprot):
        args = originalFeatures_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = originalFeatures_result()
        try:
            result.success = self._handler.originalFeatures(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("originalFeatures", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storeTreeModel(self, seqid, iprot, oprot):
        args = storeTreeModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storeTreeModel_result()
        try:
            result.success = self._handler.storeTreeModel(args.modelId, args.model)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storeTreeModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_storePipelineTransformEvent(self, seqid, iprot, oprot):
        args = storePipelineTransformEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = storePipelineTransformEvent_result()
        try:
            result.success = self._handler.storePipelineTransformEvent(args.te)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidExperimentRunException as ierEx:
            msg_type = TMessageType.REPLY
            result.ierEx = ierEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("storePipelineTransformEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_computeModelAncestry(self, seqid, iprot, oprot):
        args = computeModelAncestry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = computeModelAncestry_result()
        try:
            result.success = self._handler.computeModelAncestry(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("computeModelAncestry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_extractPipeline(self, seqid, iprot, oprot):
        args = extractPipeline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = extractPipeline_result()
        try:
            result.success = self._handler.extractPipeline(args.modelId)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ResourceNotFoundException as rnfEx:
            msg_type = TMessageType.REPLY
            result.rnfEx = rnfEx
        except ServerLogicException as svEx:
            msg_type = TMessageType.REPLY
            result.svEx = svEx
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("extractPipeline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class testConnection_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('testConnection_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class testConnection_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('testConnection_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeDataFrame_args(object):
    """
    Attributes:
     - df
     - experimentRunId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ),  # 1
        (2, TType.I32, 'experimentRunId', None, None, ),  # 2
    )

    def __init__(self, df=None, experimentRunId=None,):
        self.df = df
        self.experimentRunId = experimentRunId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.df = DataFrame()
                    self.df.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeDataFrame_args')
        if self.df is not None:
            oprot.writeFieldBegin('df', TType.STRUCT, 1)
            self.df.write(oprot)
            oprot.writeFieldEnd()
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeDataFrame_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeDataFrame_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class pathForTransformer_args(object):
    """
    Attributes:
     - transformerId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'transformerId', None, None, ),  # 1
    )

    def __init__(self, transformerId=None,):
        self.transformerId = transformerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.transformerId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('pathForTransformer_args')
        if self.transformerId is not None:
            oprot.writeFieldBegin('transformerId', TType.I32, 1)
            oprot.writeI32(self.transformerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class pathForTransformer_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - efEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'efEx', (InvalidFieldException, InvalidFieldException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, efEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.efEx = efEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.efEx = InvalidFieldException()
                    self.efEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('pathForTransformer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.efEx is not None:
            oprot.writeFieldBegin('efEx', TType.STRUCT, 2)
            self.efEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeFitEvent_args(object):
    """
    Attributes:
     - fe
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'fe', (FitEvent, FitEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, fe=None,):
        self.fe = fe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = FitEvent()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeFitEvent_args')
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeFitEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (FitEventResponse, FitEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FitEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeFitEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeMetricEvent_args(object):
    """
    Attributes:
     - me
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'me', (MetricEvent, MetricEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, me=None,):
        self.me = me

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.me = MetricEvent()
                    self.me.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeMetricEvent_args')
        if self.me is not None:
            oprot.writeFieldBegin('me', TType.STRUCT, 1)
            self.me.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeMetricEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (MetricEventResponse, MetricEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MetricEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeMetricEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilePath_args(object):
    """
    Attributes:
     - t
     - experimentRunId
     - filename
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 't', (Transformer, Transformer.thrift_spec), None, ),  # 1
        (2, TType.I32, 'experimentRunId', None, None, ),  # 2
        (3, TType.STRING, 'filename', 'UTF8', None, ),  # 3
    )

    def __init__(self, t=None, experimentRunId=None, filename=None,):
        self.t = t
        self.experimentRunId = experimentRunId
        self.filename = filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.t = Transformer()
                    self.t.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilePath_args')
        if self.t is not None:
            oprot.writeFieldBegin('t', TType.STRUCT, 1)
            self.t.write(oprot)
            oprot.writeFieldEnd()
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 3)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getFilePath_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getFilePath_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTransformEvent_args(object):
    """
    Attributes:
     - te
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'te', (TransformEvent, TransformEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, te=None,):
        self.te = te

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.te = TransformEvent()
                    self.te.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTransformEvent_args')
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.STRUCT, 1)
            self.te.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTransformEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (TransformEventResponse, TransformEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TransformEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTransformEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeRandomSplitEvent_args(object):
    """
    Attributes:
     - rse
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rse', (RandomSplitEvent, RandomSplitEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, rse=None,):
        self.rse = rse

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rse = RandomSplitEvent()
                    self.rse.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeRandomSplitEvent_args')
        if self.rse is not None:
            oprot.writeFieldBegin('rse', TType.STRUCT, 1)
            self.rse.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeRandomSplitEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (RandomSplitEventResponse, RandomSplitEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RandomSplitEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeRandomSplitEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineEvent_args(object):
    """
    Attributes:
     - pipelineEvent
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'pipelineEvent', (PipelineEvent, PipelineEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, pipelineEvent=None,):
        self.pipelineEvent = pipelineEvent

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pipelineEvent = PipelineEvent()
                    self.pipelineEvent.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineEvent_args')
        if self.pipelineEvent is not None:
            oprot.writeFieldBegin('pipelineEvent', TType.STRUCT, 1)
            self.pipelineEvent.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PipelineEventResponse, PipelineEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PipelineEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeCrossValidationEvent_args(object):
    """
    Attributes:
     - cve
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'cve', (CrossValidationEvent, CrossValidationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, cve=None,):
        self.cve = cve

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cve = CrossValidationEvent()
                    self.cve.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeCrossValidationEvent_args')
        if self.cve is not None:
            oprot.writeFieldBegin('cve', TType.STRUCT, 1)
            self.cve.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeCrossValidationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CrossValidationEventResponse, CrossValidationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CrossValidationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeCrossValidationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeGridSearchCrossValidationEvent_args(object):
    """
    Attributes:
     - gscve
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'gscve', (GridSearchCrossValidationEvent, GridSearchCrossValidationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, gscve=None,):
        self.gscve = gscve

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.gscve = GridSearchCrossValidationEvent()
                    self.gscve.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeGridSearchCrossValidationEvent_args')
        if self.gscve is not None:
            oprot.writeFieldBegin('gscve', TType.STRUCT, 1)
            self.gscve.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeGridSearchCrossValidationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GridSearchCrossValidationEventResponse, GridSearchCrossValidationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GridSearchCrossValidationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeGridSearchCrossValidationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeAnnotationEvent_args(object):
    """
    Attributes:
     - ae
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'ae', (AnnotationEvent, AnnotationEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, ae=None,):
        self.ae = ae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ae = AnnotationEvent()
                    self.ae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeAnnotationEvent_args')
        if self.ae is not None:
            oprot.writeFieldBegin('ae', TType.STRUCT, 1)
            self.ae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeAnnotationEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (AnnotationEventResponse, AnnotationEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AnnotationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeAnnotationEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeProjectEvent_args(object):
    """
    Attributes:
     - pr
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'pr', (ProjectEvent, ProjectEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, pr=None,):
        self.pr = pr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.pr = ProjectEvent()
                    self.pr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeProjectEvent_args')
        if self.pr is not None:
            oprot.writeFieldBegin('pr', TType.STRUCT, 1)
            self.pr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeProjectEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProjectEventResponse, ProjectEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProjectEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeProjectEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentEvent_args(object):
    """
    Attributes:
     - er
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'er', (ExperimentEvent, ExperimentEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, er=None,):
        self.er = er

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.er = ExperimentEvent()
                    self.er.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentEvent_args')
        if self.er is not None:
            oprot.writeFieldBegin('er', TType.STRUCT, 1)
            self.er.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentEventResponse, ExperimentEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentRunEvent_args(object):
    """
    Attributes:
     - er
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'er', (ExperimentRunEvent, ExperimentRunEvent.thrift_spec), None, ),  # 1
    )

    def __init__(self, er=None,):
        self.er = er

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.er = ExperimentRunEvent()
                    self.er.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentRunEvent_args')
        if self.er is not None:
            oprot.writeFieldBegin('er', TType.STRUCT, 1)
            self.er.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeExperimentRunEvent_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentRunEventResponse, ExperimentRunEventResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentRunEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeExperimentRunEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeLinearModel_args(object):
    """
    Attributes:
     - modelId
     - model
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRUCT, 'model', (LinearModel, LinearModel.thrift_spec), None, ),  # 2
    )

    def __init__(self, modelId=None, model=None,):
        self.modelId = modelId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.model = LinearModel()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeLinearModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 2)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeLinearModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeLinearModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDataFrameAncestry_args(object):
    """
    Attributes:
     - dataFrameId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dataFrameId', None, None, ),  # 1
    )

    def __init__(self, dataFrameId=None,):
        self.dataFrameId = dataFrameId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dataFrameId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDataFrameAncestry_args')
        if self.dataFrameId is not None:
            oprot.writeFieldBegin('dataFrameId', TType.I32, 1)
            oprot.writeI32(self.dataFrameId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getDataFrameAncestry_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (DataFrameAncestry, DataFrameAncestry.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DataFrameAncestry()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getDataFrameAncestry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestor_args(object):
    """
    Attributes:
     - dfId1
     - dfId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dfId1', None, None, ),  # 1
        (2, TType.I32, 'dfId2', None, None, ),  # 2
    )

    def __init__(self, dfId1=None, dfId2=None,):
        self.dfId1 = dfId1
        self.dfId2 = dfId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dfId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dfId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestor_args')
        if self.dfId1 is not None:
            oprot.writeFieldBegin('dfId1', TType.I32, 1)
            oprot.writeI32(self.dfId1)
            oprot.writeFieldEnd()
        if self.dfId2 is not None:
            oprot.writeFieldBegin('dfId2', TType.I32, 2)
            oprot.writeI32(self.dfId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestor_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CommonAncestor()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestor_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestorForModels_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestorForModels_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getCommonAncestorForModels_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CommonAncestor()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getCommonAncestorForModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCount_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCount_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCount_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCounts_args(object):
    """
    Attributes:
     - modelIds
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
    )

    def __init__(self, modelIds=None,):
        self.modelIds = modelIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = iprot.readI32()
                        self.modelIds.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCounts_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter359 in self.modelIds:
                oprot.writeI32(iter359)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getTrainingRowsCounts_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype363, _size360) = iprot.readListBegin()
                    for _i364 in range(_size360):
                        _elem365 = iprot.readI32()
                        self.success.append(_elem365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getTrainingRowsCounts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter366 in self.success:
                oprot.writeI32(iter366)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareHyperparameters_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareHyperparameters_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareHyperparameters_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CompareHyperParametersResponse, CompareHyperParametersResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompareHyperParametersResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareHyperparameters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareFeatures_args(object):
    """
    Attributes:
     - modelId1
     - modelId2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId1', None, None, ),  # 1
        (2, TType.I32, 'modelId2', None, None, ),  # 2
    )

    def __init__(self, modelId1=None, modelId2=None,):
        self.modelId1 = modelId1
        self.modelId2 = modelId2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.modelId2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareFeatures_args')
        if self.modelId1 is not None:
            oprot.writeFieldBegin('modelId1', TType.I32, 1)
            oprot.writeI32(self.modelId1)
            oprot.writeFieldEnd()
        if self.modelId2 is not None:
            oprot.writeFieldBegin('modelId2', TType.I32, 2)
            oprot.writeI32(self.modelId2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareFeatures_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CompareFeaturesResponse, CompareFeaturesResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CompareFeaturesResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class groupByProblemType_args(object):
    """
    Attributes:
     - modelIds
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
    )

    def __init__(self, modelIds=None,):
        self.modelIds = modelIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = iprot.readI32()
                        self.modelIds.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('groupByProblemType_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter373 in self.modelIds:
                oprot.writeI32(iter373)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class groupByProblemType_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.MAP, 'success', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype375, _vtype376, _size374) = iprot.readMapBegin()
                    for _i378 in range(_size374):
                        _key379 = iprot.readI32()
                        _val380 = []
                        (_etype384, _size381) = iprot.readListBegin()
                        for _i385 in range(_size381):
                            _elem386 = iprot.readI32()
                            _val380.append(_elem386)
                        iprot.readListEnd()
                        self.success[_key379] = _val380
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('groupByProblemType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.success))
            for kiter387, viter388 in self.success.items():
                oprot.writeI32(kiter387)
                oprot.writeListBegin(TType.I32, len(viter388))
                for iter389 in viter388:
                    oprot.writeI32(iter389)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class similarModels_args(object):
    """
    Attributes:
     - modelId
     - compMetrics
     - numModels
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.LIST, 'compMetrics', (TType.I32, None, False), None, ),  # 2
        (3, TType.I32, 'numModels', None, None, ),  # 3
    )

    def __init__(self, modelId=None, compMetrics=None, numModels=None,):
        self.modelId = modelId
        self.compMetrics = compMetrics
        self.numModels = numModels

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.compMetrics = []
                    (_etype393, _size390) = iprot.readListBegin()
                    for _i394 in range(_size390):
                        _elem395 = iprot.readI32()
                        self.compMetrics.append(_elem395)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.numModels = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('similarModels_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.compMetrics is not None:
            oprot.writeFieldBegin('compMetrics', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.compMetrics))
            for iter396 in self.compMetrics:
                oprot.writeI32(iter396)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.numModels is not None:
            oprot.writeFieldBegin('numModels', TType.I32, 3)
            oprot.writeI32(self.numModels)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class similarModels_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - brEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, brEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.brEx = brEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype400, _size397) = iprot.readListBegin()
                    for _i401 in range(_size397):
                        _elem402 = iprot.readI32()
                        self.success.append(_elem402)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.brEx = BadRequestException()
                    self.brEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('similarModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter403 in self.success:
                oprot.writeI32(iter403)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.brEx is not None:
            oprot.writeFieldBegin('brEx', TType.STRUCT, 2)
            self.brEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linearModelFeatureImportances_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('linearModelFeatureImportances_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class linearModelFeatureImportances_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype407, _size404) = iprot.readListBegin()
                    for _i408 in range(_size404):
                        _elem409 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem409)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('linearModelFeatureImportances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter410 in self.success:
                oprot.writeString(iter410.encode('utf-8') if sys.version_info[0] == 2 else iter410)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareLinearModelFeatureImportances_args(object):
    """
    Attributes:
     - model1Id
     - model2Id
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'model1Id', None, None, ),  # 1
        (2, TType.I32, 'model2Id', None, None, ),  # 2
    )

    def __init__(self, model1Id=None, model2Id=None,):
        self.model1Id = model1Id
        self.model2Id = model2Id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.model1Id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.model2Id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareLinearModelFeatureImportances_args')
        if self.model1Id is not None:
            oprot.writeFieldBegin('model1Id', TType.I32, 1)
            oprot.writeI32(self.model1Id)
            oprot.writeFieldEnd()
        if self.model2Id is not None:
            oprot.writeFieldBegin('model2Id', TType.I32, 2)
            oprot.writeI32(self.model2Id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compareLinearModelFeatureImportances_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FeatureImportanceComparison, FeatureImportanceComparison.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype414, _size411) = iprot.readListBegin()
                    for _i415 in range(_size411):
                        _elem416 = FeatureImportanceComparison()
                        _elem416.read(iprot)
                        self.success.append(_elem416)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compareLinearModelFeatureImportances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter417 in self.success:
                iter417.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 3)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class iterationsUntilConvergence_args(object):
    """
    Attributes:
     - modelIds
     - tolerance
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
        (2, TType.DOUBLE, 'tolerance', None, None, ),  # 2
    )

    def __init__(self, modelIds=None, tolerance=None,):
        self.modelIds = modelIds
        self.tolerance = tolerance

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype421, _size418) = iprot.readListBegin()
                    for _i422 in range(_size418):
                        _elem423 = iprot.readI32()
                        self.modelIds.append(_elem423)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.tolerance = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('iterationsUntilConvergence_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter424 in self.modelIds:
                oprot.writeI32(iter424)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tolerance is not None:
            oprot.writeFieldBegin('tolerance', TType.DOUBLE, 2)
            oprot.writeDouble(self.tolerance)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class iterationsUntilConvergence_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype428, _size425) = iprot.readListBegin()
                    for _i429 in range(_size425):
                        _elem430 = iprot.readI32()
                        self.success.append(_elem430)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('iterationsUntilConvergence_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter431 in self.success:
                oprot.writeI32(iter431)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rankModels_args(object):
    """
    Attributes:
     - modelIds
     - metric
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'modelIds', (TType.I32, None, False), None, ),  # 1
        (2, TType.I32, 'metric', None, None, ),  # 2
    )

    def __init__(self, modelIds=None, metric=None,):
        self.modelIds = modelIds
        self.metric = metric

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.modelIds = []
                    (_etype435, _size432) = iprot.readListBegin()
                    for _i436 in range(_size432):
                        _elem437 = iprot.readI32()
                        self.modelIds.append(_elem437)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.metric = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rankModels_args')
        if self.modelIds is not None:
            oprot.writeFieldBegin('modelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.modelIds))
            for iter438 in self.modelIds:
                oprot.writeI32(iter438)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metric is not None:
            oprot.writeFieldBegin('metric', TType.I32, 2)
            oprot.writeI32(self.metric)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rankModels_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype442, _size439) = iprot.readListBegin()
                    for _i443 in range(_size439):
                        _elem444 = iprot.readI32()
                        self.success.append(_elem444)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rankModels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter445 in self.success:
                oprot.writeI32(iter445)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class confidenceIntervals_args(object):
    """
    Attributes:
     - modelId
     - sigLevel
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.DOUBLE, 'sigLevel', None, None, ),  # 2
    )

    def __init__(self, modelId=None, sigLevel=None,):
        self.modelId = modelId
        self.sigLevel = sigLevel

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.sigLevel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('confidenceIntervals_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.sigLevel is not None:
            oprot.writeFieldBegin('sigLevel', TType.DOUBLE, 2)
            oprot.writeDouble(self.sigLevel)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class confidenceIntervals_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - ioEx
     - brEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ConfidenceInterval, ConfidenceInterval.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, rnfEx=None, ioEx=None, brEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.ioEx = ioEx
        self.brEx = brEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype449, _size446) = iprot.readListBegin()
                    for _i450 in range(_size446):
                        _elem451 = ConfidenceInterval()
                        _elem451.read(iprot)
                        self.success.append(_elem451)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ioEx = IllegalOperationException()
                    self.ioEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.brEx = BadRequestException()
                    self.brEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('confidenceIntervals_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter452 in self.success:
                iter452.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.ioEx is not None:
            oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
            self.ioEx.write(oprot)
            oprot.writeFieldEnd()
        if self.brEx is not None:
            oprot.writeFieldBegin('brEx', TType.STRUCT, 3)
            self.brEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 4)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsWithFeatures_args(object):
    """
    Attributes:
     - featureNames
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'featureNames', (TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, featureNames=None,):
        self.featureNames = featureNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.featureNames = []
                    (_etype456, _size453) = iprot.readListBegin()
                    for _i457 in range(_size453):
                        _elem458 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.featureNames.append(_elem458)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsWithFeatures_args')
        if self.featureNames is not None:
            oprot.writeFieldBegin('featureNames', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.featureNames))
            for iter459 in self.featureNames:
                oprot.writeString(iter459.encode('utf-8') if sys.version_info[0] == 2 else iter459)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsWithFeatures_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype463, _size460) = iprot.readListBegin()
                    for _i464 in range(_size460):
                        _elem465 = iprot.readI32()
                        self.success.append(_elem465)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsWithFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter466 in self.success:
                oprot.writeI32(iter466)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsDerivedFromDataFrame_args(object):
    """
    Attributes:
     - dfId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'dfId', None, None, ),  # 1
    )

    def __init__(self, dfId=None,):
        self.dfId = dfId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dfId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsDerivedFromDataFrame_args')
        if self.dfId is not None:
            oprot.writeFieldBegin('dfId', TType.I32, 1)
            oprot.writeI32(self.dfId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class modelsDerivedFromDataFrame_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype470, _size467) = iprot.readListBegin()
                    for _i471 in range(_size467):
                        _elem472 = iprot.readI32()
                        self.success.append(_elem472)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('modelsDerivedFromDataFrame_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter473 in self.success:
                oprot.writeI32(iter473)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectIds_args(object):
    """
    Attributes:
     - keyValuePairs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyValuePairs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, keyValuePairs=None,):
        self.keyValuePairs = keyValuePairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.keyValuePairs = {}
                    (_ktype475, _vtype476, _size474) = iprot.readMapBegin()
                    for _i478 in range(_size474):
                        _key479 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val480 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyValuePairs[_key479] = _val480
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectIds_args')
        if self.keyValuePairs is not None:
            oprot.writeFieldBegin('keyValuePairs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyValuePairs))
            for kiter481, viter482 in self.keyValuePairs.items():
                oprot.writeString(kiter481.encode('utf-8') if sys.version_info[0] == 2 else kiter481)
                oprot.writeString(viter482.encode('utf-8') if sys.version_info[0] == 2 else viter482)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectIds_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype486, _size483) = iprot.readListBegin()
                    for _i487 in range(_size483):
                        _elem488 = iprot.readI32()
                        self.success.append(_elem488)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter489 in self.success:
                oprot.writeI32(iter489)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModelIds_args(object):
    """
    Attributes:
     - keyValuePairs
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'keyValuePairs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    )

    def __init__(self, keyValuePairs=None,):
        self.keyValuePairs = keyValuePairs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.keyValuePairs = {}
                    (_ktype491, _vtype492, _size490) = iprot.readMapBegin()
                    for _i494 in range(_size490):
                        _key495 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val496 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyValuePairs[_key495] = _val496
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModelIds_args')
        if self.keyValuePairs is not None:
            oprot.writeFieldBegin('keyValuePairs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyValuePairs))
            for kiter497, viter498 in self.keyValuePairs.items():
                oprot.writeString(kiter497.encode('utf-8') if sys.version_info[0] == 2 else kiter497)
                oprot.writeString(viter498.encode('utf-8') if sys.version_info[0] == 2 else viter498)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModelIds_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = iprot.readI32()
                        self.success.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModelIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter505 in self.success:
                oprot.writeI32(iter505)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateProject_args(object):
    """
    Attributes:
     - projectId
     - key
     - value
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projectId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
    )

    def __init__(self, projectId=None, key=None, value=None,):
        self.projectId = projectId
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateProject_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.I32, 1)
            oprot.writeI32(self.projectId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createOrUpdateScalarField_args(object):
    """
    Attributes:
     - modelId
     - key
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'valueType', 'UTF8', None, ),  # 4
    )

    def __init__(self, modelId=None, key=None, value=None, valueType=None,):
        self.modelId = modelId
        self.key = key
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createOrUpdateScalarField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 4)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createOrUpdateScalarField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createOrUpdateScalarField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createVectorField_args(object):
    """
    Attributes:
     - modelId
     - vectorName
     - vectorConfig
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'vectorName', 'UTF8', None, ),  # 2
        (3, TType.MAP, 'vectorConfig', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, modelId=None, vectorName=None, vectorConfig=None,):
        self.modelId = modelId
        self.vectorName = vectorName
        self.vectorConfig = vectorConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.vectorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.vectorConfig = {}
                    (_ktype507, _vtype508, _size506) = iprot.readMapBegin()
                    for _i510 in range(_size506):
                        _key511 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val512 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vectorConfig[_key511] = _val512
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.vectorName is not None:
            oprot.writeFieldBegin('vectorName', TType.STRING, 2)
            oprot.writeString(self.vectorName.encode('utf-8') if sys.version_info[0] == 2 else self.vectorName)
            oprot.writeFieldEnd()
        if self.vectorConfig is not None:
            oprot.writeFieldBegin('vectorConfig', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vectorConfig))
            for kiter513, viter514 in self.vectorConfig.items():
                oprot.writeString(kiter513.encode('utf-8') if sys.version_info[0] == 2 else kiter513)
                oprot.writeString(viter514.encode('utf-8') if sys.version_info[0] == 2 else viter514)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class createVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('createVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateVectorField_args(object):
    """
    Attributes:
     - modelId
     - key
     - valueIndex
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
        (3, TType.I32, 'valueIndex', None, None, ),  # 3
        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'valueType', 'UTF8', None, ),  # 5
    )

    def __init__(self, modelId=None, key=None, valueIndex=None, value=None, valueType=None,):
        self.modelId = modelId
        self.key = key
        self.valueIndex = valueIndex
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.valueIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.valueIndex is not None:
            oprot.writeFieldBegin('valueIndex', TType.I32, 3)
            oprot.writeI32(self.valueIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 5)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class updateVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('updateVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class appendToVectorField_args(object):
    """
    Attributes:
     - modelId
     - vectorName
     - value
     - valueType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRING, 'vectorName', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'valueType', 'UTF8', None, ),  # 4
    )

    def __init__(self, modelId=None, vectorName=None, value=None, valueType=None,):
        self.modelId = modelId
        self.vectorName = vectorName
        self.value = value
        self.valueType = valueType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.vectorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.valueType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('appendToVectorField_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.vectorName is not None:
            oprot.writeFieldBegin('vectorName', TType.STRING, 2)
            oprot.writeString(self.vectorName.encode('utf-8') if sys.version_info[0] == 2 else self.vectorName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.valueType is not None:
            oprot.writeFieldBegin('valueType', TType.STRING, 4)
            oprot.writeString(self.valueType.encode('utf-8') if sys.version_info[0] == 2 else self.valueType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class appendToVectorField_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('appendToVectorField_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ModelResponse, ModelResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ModelResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsInExperiment_args(object):
    """
    Attributes:
     - experimentId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentId', None, None, ),  # 1
    )

    def __init__(self, experimentId=None,):
        self.experimentId = experimentId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsInExperiment_args')
        if self.experimentId is not None:
            oprot.writeFieldBegin('experimentId', TType.I32, 1)
            oprot.writeI32(self.experimentId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsInExperiment_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ExperimentRun, ExperimentRun.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype518, _size515) = iprot.readListBegin()
                    for _i519 in range(_size515):
                        _elem520 = ExperimentRun()
                        _elem520.read(iprot)
                        self.success.append(_elem520)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsInExperiment_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter521 in self.success:
                iter521.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsAndExperimentsInProject_args(object):
    """
    Attributes:
     - projId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'projId', None, None, ),  # 1
    )

    def __init__(self, projId=None,):
        self.projId = projId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.projId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsAndExperimentsInProject_args')
        if self.projId is not None:
            oprot.writeFieldBegin('projId', TType.I32, 1)
            oprot.writeI32(self.projId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getRunsAndExperimentsInProject_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ProjectExperimentsAndRuns, ProjectExperimentsAndRuns.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ProjectExperimentsAndRuns()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getRunsAndExperimentsInProject_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectOverviews_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectOverviews_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getProjectOverviews_result(object):
    """
    Attributes:
     - success
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (ProjectOverviewResponse, ProjectOverviewResponse.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, svEx=None,):
        self.success = success
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = ProjectOverviewResponse()
                        _elem527.read(iprot)
                        self.success.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getProjectOverviews_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter528 in self.success:
                iter528.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperimentRunDetails_args(object):
    """
    Attributes:
     - experimentRunId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'experimentRunId', None, None, ),  # 1
    )

    def __init__(self, experimentRunId=None,):
        self.experimentRunId = experimentRunId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.experimentRunId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperimentRunDetails_args')
        if self.experimentRunId is not None:
            oprot.writeFieldBegin('experimentRunId', TType.I32, 1)
            oprot.writeI32(self.experimentRunId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getExperimentRunDetails_result(object):
    """
    Attributes:
     - success
     - svEx
     - rnfEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExperimentRunDetailsResponse, ExperimentRunDetailsResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, svEx=None, rnfEx=None,):
        self.success = success
        self.svEx = svEx
        self.rnfEx = rnfEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExperimentRunDetailsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getExperimentRunDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 1)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 2)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class originalFeatures_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('originalFeatures_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class originalFeatures_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype532, _size529) = iprot.readListBegin()
                    for _i533 in range(_size529):
                        _elem534 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem534)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('originalFeatures_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter535 in self.success:
                oprot.writeString(iter535.encode('utf-8') if sys.version_info[0] == 2 else iter535)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTreeModel_args(object):
    """
    Attributes:
     - modelId
     - model
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
        (2, TType.STRUCT, 'model', (TreeModel, TreeModel.thrift_spec), None, ),  # 2
    )

    def __init__(self, modelId=None, model=None,):
        self.modelId = modelId
        self.model = model

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.model = TreeModel()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTreeModel_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 2)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storeTreeModel_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storeTreeModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineTransformEvent_args(object):
    """
    Attributes:
     - te
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'te', (TType.STRUCT, (TransformEvent, TransformEvent.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, te=None,):
        self.te = te

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.te = []
                    (_etype539, _size536) = iprot.readListBegin()
                    for _i540 in range(_size536):
                        _elem541 = TransformEvent()
                        _elem541.read(iprot)
                        self.te.append(_elem541)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineTransformEvent_args')
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.te))
            for iter542 in self.te:
                iter542.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class storePipelineTransformEvent_result(object):
    """
    Attributes:
     - success
     - ierEx
     - svEx
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (TransformEventResponse, TransformEventResponse.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, ierEx=None, svEx=None,):
        self.success = success
        self.ierEx = ierEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype546, _size543) = iprot.readListBegin()
                    for _i547 in range(_size543):
                        _elem548 = TransformEventResponse()
                        _elem548.read(iprot)
                        self.success.append(_elem548)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ierEx = InvalidExperimentRunException()
                    self.ierEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('storePipelineTransformEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter549 in self.success:
                iter549.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ierEx is not None:
            oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
            self.ierEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class computeModelAncestry_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('computeModelAncestry_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class computeModelAncestry_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ModelAncestryResponse, ModelAncestryResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ModelAncestryResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('computeModelAncestry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class extractPipeline_args(object):
    """
    Attributes:
     - modelId
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'modelId', None, None, ),  # 1
    )

    def __init__(self, modelId=None,):
        self.modelId = modelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('extractPipeline_args')
        if self.modelId is not None:
            oprot.writeFieldBegin('modelId', TType.I32, 1)
            oprot.writeI32(self.modelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class extractPipeline_result(object):
    """
    Attributes:
     - success
     - rnfEx
     - svEx
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ExtractedPipelineResponse, ExtractedPipelineResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'svEx', (ServerLogicException, ServerLogicException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, rnfEx=None, svEx=None,):
        self.success = success
        self.rnfEx = rnfEx
        self.svEx = svEx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExtractedPipelineResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.rnfEx = ResourceNotFoundException()
                    self.rnfEx.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.svEx = ServerLogicException()
                    self.svEx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('extractPipeline_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.rnfEx is not None:
            oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
            self.rnfEx.write(oprot)
            oprot.writeFieldEnd()
        if self.svEx is not None:
            oprot.writeFieldBegin('svEx', TType.STRUCT, 2)
            self.svEx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
