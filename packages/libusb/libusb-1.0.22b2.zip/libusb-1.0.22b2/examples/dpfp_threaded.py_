# Copyright (c) 2016-2018, Adam Karpierz
# Licensed under the zlib/libpng License
# http://opensource.org/licenses/zlib

# libusb example program to manipulate U.are.U 4000B fingerprint scanner.
# Copyright © 2007 Daniel Drake <dsd@gentoo.org>
# Copyright © 2016 Nathan Hjelm <hjelmn@mac.com>
#
# Basic image capture program only, does not consider the powerup quirks or
# the fact that image encryption may be enabled. Not expected to work
# flawlessly all of the time.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

from __future__ import absolute_import, division, print_function

import sys
import ctypes as ct
import libusb as usb

static inline void usb_fill_interrupt_transfer(
    struct libusb_transfer *transfer,
    libusb_device_handle *dev_handle,
    unsigned char endpoint,
    unsigned char *buffer,
    int length,
    libusb_transfer_cb_fn callback,
    void *user_data,
    unsigned int timeout):

    transfer.dev_handle = dev_handle
    transfer.endpoint   = endpoint
    transfer.type       = usb.LIBUSB_TRANSFER_TYPE_INTERRUPT
    transfer.timeout    = timeout
    transfer.buffer     = buffer
    transfer.length     = length
    transfer.user_data  = user_data
    transfer.callback   = callback

#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <fcntl.h>

EP_INTR     = 1 | LIBUSB_ENDPOINT_IN
EP_DATA     = 2 | LIBUSB_ENDPOINT_IN
CTRL_IN     = LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_ENDPOINT_IN
CTRL_OUT    = LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_ENDPOINT_OUT
USB_RQ      = 0x04
INTR_LENGTH = 64
SEM_NAME    = "/org.libusb.example.dpfp_threaded"

MODE_INIT             = 0x00
MODE_AWAIT_FINGER_ON  = 0x10
MODE_AWAIT_FINGER_OFF = 0x12
MODE_CAPTURE          = 0x20
MODE_SHUT_UP          = 0x30
MODE_READY            = 0x80

STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_ON  = 1
STATE_AWAIT_IRQ_FINGER_DETECTED          = 2
STATE_AWAIT_MODE_CHANGE_CAPTURE          = 3
STATE_AWAIT_IMAGE                        = 4
STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_OFF = 5
STATE_AWAIT_IRQ_FINGER_REMOVED           = 6

state = 0
static struct usb.device_handle* devh = NULL;
static unsigned char imgbuf[0x1b340];
static unsigned char irqbuf[INTR_LENGTH];
static usb.transfer* img_transfer = NULL;
static usb.transfer* irq_transfer = NULL;
img_idx = 0
do_exit = 0  # volatile sig_atomic_t

static pthread_t poll_thread;
static sem_t *exit_sem;


static def request_exit(sig_atomic_t code):

    global do_exit

    do_exit = code
    sem_post(exit_sem)


static void* poll_thread_main(void *arg):

    global do_exit

    print("poll thread running")

    while not do_exit:
        struct timeval tv = { 1, 0 };
        r = usb.handle_events_timeout(NULL, &tv)
        if r < 0:
            request_exit(2)
            break

    print("poll thread shutting down")
    return NULL


def find_dpfp_device():

    devh = usb.open_device_with_vid_pid(NULL, 0x05ba, 0x000a)
    return 0 if devh else -EIO


def print_f0_data():

    unsigned char data[0x10];

    r = usb.control_transfer(devh, CTRL_IN, USB_RQ, 0xf0, 0, data, sizeof(data), 0)
    if r < 0:
        print(stderr, "F0 error %d", r)
        return r
    if (unsigned int) r < sizeof(data):
        print(stderr, "short read (%d)", r)
        return -1

    printf("F0 data:")
    for (i = 0; i < sizeof(data); i++):
        printf("%02x ", data[i])
    print()
    return 0


def get_hwstat(unsigned char *status):

    r = usb.control_transfer(devh, CTRL_IN, USB_RQ, 0x07, 0, status, 1, 0)
    if r < 0:
        print(stderr, "read hwstat error %d", r)
        return r
    if (unsigned int) r < 1:
        print(stderr, "short read (%d)", r)
        return -1

    print("hwstat reads %02x", *status)
    return 0


def set_hwstat(unsigned char data):

    print("set hwstat to %02x", data)

    r = usb.control_transfer(devh, CTRL_OUT, USB_RQ, 0x07, 0, &data, 1, 0)
    if r < 0:
        print(stderr, "set hwstat error %d", r)
        return r
    if (unsigned int) r < 1:
        fprintf(stderr, "short write (%d)", r)
        return -1

    return 0


def set_mode(unsigned char data):

    print("set mode %02x", data)

    r = usb.control_transfer(devh, CTRL_OUT, USB_RQ, 0x4e, 0, &data, 1, 0)
    if r < 0:
        print(stderr, "set mode error %d", r)
        return r
    if (unsigned int) r < 1:
        fprintf(stderr, "short write (%d)", r)
        return -1

    return 0


static def LIBUSB_CALL cb_mode_changed(usb.transfer *transfer):

    if transfer.status != LIBUSB_TRANSFER_COMPLETED:
        print(stderr, "mode change transfer not completed!")
        request_exit(2)

    print("async cb_mode_changed length=%d actual_length=%d",
          transfer.length, transfer.actual_length)
    if next_state() < 0:
        request_exit(2)


static int set_mode_async(unsigned char data):

    unsigned char *buf = (unsigned char*) malloc(LIBUSB_CONTROL_SETUP_SIZE + 1)
    if not buf:
        return -ENOMEM

    transfer = usb.alloc_transfer(0)  # usb.transfer*
    if not transfer:
        free(buf);
        return -ENOMEM

    print("async set mode %02x", data)
    usb.fill_control_setup(buf, CTRL_OUT, USB_RQ, 0x4e, 0, 1)
    buf[LIBUSB_CONTROL_SETUP_SIZE] = data
    usb.fill_control_transfer(transfer, devh, buf, cb_mode_changed, NULL, 1000)

    transfer.flags = (LIBUSB_TRANSFER_SHORT_NOT_OK |
                      LIBUSB_TRANSFER_FREE_BUFFER  |
                      LIBUSB_TRANSFER_FREE_TRANSFER)
    return usb.submit_transfer(transfer)


def do_sync_intr(unsigned char *data):

    int transferred;
    r = usb.interrupt_transfer(devh, EP_INTR, data, INTR_LENGTH, &transferred, 1000)
    if r < 0:
        print(stderr, "intr error %d", r)
        return r
    if transferred < INTR_LENGTH:
        print(stderr, "short read (%d)", r)
        return -1

    print("recv interrupt %04x", *((uint16_t *) data))
    return 0


static int sync_intr(unsigned char type):

    unsigned char data[INTR_LENGTH];

    while True:
        r = do_sync_intr(data)
        if r < 0:
            return r
        if data[0] == type:
            return 0


def save_to_file(unsigned char *data):

    global img_idx

    char filename[64];
    snprintf(filename, sizeof(filename), "finger%d.pgm", img_idx)
    img_idx += 1
    fd = fopen(filename, "w")  # FILE*
    if not fd:
        return -1

    fputs("P5 384 289 255 ", fd)
    fwrite(data + 64, 1, 384*289, fd)
    fclose(fd)
    print("saved image to %s", filename)
    return 0


static int next_state():

    global state

    print("old state: {}".format(state))

    r = 0
    if state == STATE_AWAIT_IRQ_FINGER_REMOVED:
        state = STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_ON
        r = set_mode_async(MODE_AWAIT_FINGER_ON)
    elif state == STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_ON:
        state = STATE_AWAIT_IRQ_FINGER_DETECTED
    elif state == STATE_AWAIT_IRQ_FINGER_DETECTED:
        state = STATE_AWAIT_MODE_CHANGE_CAPTURE
        r = set_mode_async(MODE_CAPTURE)
    elif state == STATE_AWAIT_MODE_CHANGE_CAPTURE:
        state = STATE_AWAIT_IMAGE
    elif state == STATE_AWAIT_IMAGE:
        state = STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_OFF
        r = set_mode_async(MODE_AWAIT_FINGER_OFF)
    elif state == STATE_AWAIT_MODE_CHANGE_AWAIT_FINGER_OFF:
        state = STATE_AWAIT_IRQ_FINGER_REMOVED
    else:
        print("unrecognised state {}".format(state))
    if r < 0:
        print(stderr, "error detected changing state")
        return r

    print("new state: {}".format(state))
    return 0


static def LIBUSB_CALL cb_irq(usb.transfer *transfer):

    global state

    unsigned char irqtype = transfer.buffer[0]

    if transfer.status != LIBUSB_TRANSFER_COMPLETED:
        print(stderr, "irq transfer status %d?", transfer.status)
        irq_transfer = NULL
        request_exit(2)
        return

    print("IRQ callback %02x", irqtype)

    if state == STATE_AWAIT_IRQ_FINGER_DETECTED:
        if irqtype == 0x01:
            if next_state() < 0:
                request_exit(2)
                return
        else:
            print("finger-on-sensor detected in wrong state!")
    elif state == STATE_AWAIT_IRQ_FINGER_REMOVED:
        if irqtype == 0x02:
            if next_state() < 0:
                request_exit(2)
                return
        else:
            print("finger-on-sensor detected in wrong state!")

    if usb.submit_transfer(irq_transfer) < 0:
        request_exit(2)


static def LIBUSB_CALL cb_img(usb.transfer *transfer):

    if transfer.status != LIBUSB_TRANSFER_COMPLETED:
        print(stderr, "img transfer status %d?", transfer.status)
        img_transfer = NULL
        request_exit(2)
        return

    print("Image callback")
    save_to_file(imgbuf)
    if next_state() < 0:
        request_exit(2)
        return

    if usb.submit_transfer(img_transfer) < 0:
        request_exit(2)


static int init_capture():

    global state

    r = usb.submit_transfer(irq_transfer)
    if r < 0:
        return r

    r = usb.submit_transfer(img_transfer)
    if r < 0:
        usb.cancel_transfer(irq_transfer)
        while irq_transfer:
            if usb.handle_events(NULL) < 0:
                break
        return r

    # start state machine
    state = STATE_AWAIT_IRQ_FINGER_REMOVED
    return next_state()


static int do_init():

    unsigned char status;
    r = get_hwstat(&status)
    if r < 0:
        return r

    if not (status & 0x80):
        r = set_hwstat(status | 0x80)
        if r < 0:
            return r
        r = get_hwstat(&status)
        if r < 0:
            return r

    status &= ~0x80
    r = set_hwstat(status)
    if r < 0:
        return r

    r = get_hwstat(&status)
    if r < 0:
        return r

    r = sync_intr(0x56)
    if r < 0:
        return r

    return 0


static int alloc_transfers():

    img_transfer = usb.alloc_transfer(0)
    if not img_transfer:
        return -ENOMEM

    irq_transfer = usb.alloc_transfer(0)
    if not irq_transfer:
        return -ENOMEM

    usb.fill_bulk_transfer(img_transfer, devh, EP_DATA, imgbuf,
                           sizeof(imgbuf), cb_img, NULL, 0)
    usb_fill_interrupt_transfer(irq_transfer, devh, EP_INTR, irqbuf,
                                sizeof(irqbuf), cb_irq, NULL, 0)
    return 0


static def sighandler(int signum):

    request_exit(1)


def main():

    global do_exit

    struct sigaction sigact;

    exit_sem = sem_open(SEM_NAME, O_CREAT, 0)
    if not exit_sem:
        print(stderr, "failed to initialise semaphore error %d", errno)
        sys.exit(1)

    # only using this semaphore in this process so go ahead and unlink it now
    sem_unlink(SEM_NAME)

    r = usb.init(None)
    if r < 0:
        print(stderr, "failed to initialise libusb")
        sys.exit(1)

    r = find_dpfp_device();
    if r < 0:
        print(stderr, "Could not find/open device")
        goto out;

    r = usb.claim_interface(devh, 0)
    if r < 0:
        print(stderr, "usb_claim_interface error %d %s", r, strerror(-r))
        goto out;
    print("claimed interface")

    r = print_f0_data()
    if r < 0:
        goto out_release;

    r = do_init()
    if r < 0:
        goto out_deinit;

    # async from here onwards

    sigact.sa_handler = sighandler
    sigemptyset(&sigact.sa_mask)
    sigact.sa_flags = 0
    sigaction(SIGINT,  &sigact, NULL)
    sigaction(SIGTERM, &sigact, NULL)
    sigaction(SIGQUIT, &sigact, NULL)

    r = pthread_create(&poll_thread, NULL, poll_thread_main, NULL)
    if r:
        goto out_deinit;

    r = alloc_transfers()
    if r < 0:
        request_exit(1)
        pthread_join(poll_thread, NULL)
        goto out_deinit;

    r = init_capture()
    if r < 0:
        request_exit(1)
        pthread_join(poll_thread, NULL)
        goto out_deinit;

    while not do_exit:
        sem_wait(exit_sem)

    print("shutting down...")
    pthread_join(poll_thread, NULL)

    r = usb.cancel_transfer(irq_transfer)
    if r < 0:
        request_exit(1)
        goto out_deinit;

    r = usb.cancel_transfer(img_transfer)
    if r < 0:
        request_exit(1)
        goto out_deinit;

    while irq_transfer or img_transfer:
        if usb.handle_events(NULL) < 0:
            break

    r = 0 if do_exit == 1 else 1

    out_deinit:
    usb.free_transfer(img_transfer)
    usb.free_transfer(irq_transfer)
    set_mode(0);
    set_hwstat(0x80)

    out_release:
    usb.release_interface(devh, 0)

    out:
    usb.close(devh)
    usb.exit(None)

    return abs(r)


sys.exit(main() or 0)
