# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['typedtsv']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'typedtsv',
    'version': '0.9.0',
    'description': 'A simple format for typing TSVs with an implementation in Python 3',
    'long_description': "# typedtsv\nTyped TSV: A simple format for typing TSVs with an implementation in Python 3.\n\nAvailable on pypi: https://pypi.org/project/typedtsv/\n\nInstall with `pip install typedtsv`\n\n## Why?\nJSON, YAML, TOML and other simple formats aren't built for list/table like sets of data.\n\nYAML is particularly slow due to its expansive featureset and JSON, being that is for single objects and not collections, is not chunkable.  I once stored all PyPI package info in a YAML file and reading it back out was going to take half a day.  Using a dead-simple newline-delimited JSON format made parsing take seconds.\n\nNewline-delimited JSON is convenient with little chance of making mistakes in parsing and good performance.  The downsides are the types supported are a bit too limited (no int vs float), and it is also not easily human readable or editable.\n\nTOML is particularly targeted towards configuration files and similarly parses results in a single dictionary object rather than a collection.\n\nCSV/TSV formats have too much ambiguity resulting in repetitive custom parsing logic contained outside the file itself.  CSV quote escaping can also lead to poor parsing performance.\n\n## Goals\n- Be simple\n- Be fast\n- Be easily parallelized\n- Be a better alternative to CSV/TSV/JSON and simple uses of YAML\n- Support open data and data sharing/archival. Push information about a dataset into the data file itself for future reproducibility\n\n### Use Cases in Mind\n- Database-agnostic, program-agnostic simple file format for open data\n- A quick go-to serialization format for sharing reproducible data science datasets\n- Easily-created, easily-editable, easily-understood database fixtures for tests\n\n## Non-Goals\n- Unlimited extensibility a la YAML\n- Config files. Focus is on lists of objects/tabular data\n\n## Format\nFormat is a normal TSV except the header rows uses a colon format to annotate the type:\n\n`<col_name>:<col_type>\\t<col_name2>:<coL_type2>...`\n\nFor example:\n\n```\n# I'm a comment and will be ignored\nurl:str    n_times:int   score:float\nhttps://www.example.com 5   1.6\nhttps://archive.org 99  9.9\n```\n\nInitial pass centered around Python's basic types plus JSON.  Current valid types are:\n\n| Type     | Notes                                               |\n|----------|------------------------------------------------------\n| int      |                                                     |\n| float    |                                                     |\n| bool     | Valid values: true, false, t, f, yes, no, y, n, 1, 0|\n| str      | Newlines, tabs, \\\\, and #  must be escaped           |\n| datetime | '2011-01-01 00:00:00' Without timezone assumes UTC  |\n| json     |                                                     |\n|          |                                                     |\n| null     | All types are nullable with value 'null'.  To get literal string 'null', use '\\\\null'|\n\nComments are supported, just prefix with #.  Escape actual # in a string with a single backslash '\\\\#'.\n\nRow separators use `'\\n'` only.  Windows line breaks, `'\\r\\n'` are not valid.\n\nWe'll never allow quoted `'\\n'` because this would make the file difficult to chunk and thus make it difficult to parallelize reading.\n\n**Gotchas**:\n- In Python, you need to be careful about opening files that may contain Windows newlines:\n```py\ninfile = open('data.ttsv', 'r', newline='\\n')   # must set newline='\\n' because default for newline is '\\n' or '\\r' or '\\r\\n'\n```\n- typedtsv.dumps can infer column types from the first row of your data but not if there are any ```null```'s.  In that case, use the regular OrderedDict method to define column names and types\n\n## TODO:\n- ~~Add a boolean type~~\n- ~~Add nulls~~\n- ~~Add a datetime/date/time type: need to avoid ambiguity yet support common uses~~\n- ~~Ergonomics: optionally read and dump single lists of data rather than dealing with a list of lists~~\n- Support units annotations such as degrees F, meters/second using similar using same syntax as F#: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure\n- Maybe: extend format to support column comments / other common metadata\n- Maybe: support array and map types for compatibility with Postgres\n- Maybe: Support date, time, and/or timeinterval types\n\n## Developing\n\nMake sure you have Poetry installed: https://github.com/sdispater/poetry\n\n```bash\ngit clone git@github.com:jimmybot/typedtsv.git\ncd typedtsv\npoetry install\npoetry shell\npytest\n```\n",
    'author': 'jimmybot',
    'author_email': 'jimmybot@jimmybot.com',
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.6',
}


setup(**setup_kwargs)
