
# If a bed file of editing islands is passed Adar1 and Adar2 counts will also be printed.
# Gives counts of how may editing sites fall in what kind of features e.g. introns, exons.


min_site_coverage_message_default = 5
min_site_editing_message_default = 3
max_site_editing_message_default = 0.99

gtf_help_message = """ A GTF file containing genomic annotations (Ensembl recommended).

"""

min_site_coverage_message = """ Ignore sites with coverage less than N. (Default: %s)

""" % min_site_coverage_message_default

min_site_editing_message = """ Ignore sites with less than N edited bases. (Default: %s)

""" % min_site_editing_message_default

max_site_editing_message = """ Editing sites with alt/ref ratios higher \
than this number will be excluded.
 Must be a float between 0.0 - 1.0. (Default: %s)
""" % max_site_editing_message_default

region_message = """ A bed file containing genomic coordinates.

"""

alignment_help_string = """ A BAM file. In most cases will also require a index (BAI) file.

"""

coverage_message = """ Files generated by: samtools view -b {input} | genomeCoverageBed -ibam stdin -g > {output}

"""


alignment_help_string = """

"""

vcf_file_help_string = """ VCF formatted files containing editing sites.

"""

alignment_help_string = """ A sorted and indexed BAM, CRAM, or SAM file.

"""

min_qscore_help_string = """ The minimum Phred quality score (Q score) needed for DRETools to count a base.
 Larger values indicate higher quality. Values 0-40 possible, but values less than 20 not recommended.

"""


def alignment_parameters(parser, nargs="?"):

    parser.add_argument(
        "--alignment",
        type=str,
        nargs=nargs,
        help=alignment_help_string
    )

    parser.add_argument(
        "--min-qscore",
        type=int,
        default=30,
        help=min_qscore_help_string
    )


def max_editing(parser):
    parser.add_argument(
        "--max-editing",
        type=float,
        default=0.99,
        help=max_site_editing_message
    )


def vcf_params(parser):
    """

    :param parser:
    :return:
    """
    parser.add_argument(
        "--vcf",
        nargs='+',
        type=str,
        help=vcf_file_help_string)

    parser.add_argument(
        "--min-coverage",
        type=int,
        default=3,
        help=min_site_coverage_message
    )

    parser.add_argument(
        "--min-editing",
        type=int,
        default=2,
        help=min_site_editing_message
    )

    max_editing(parser)

def shared_params(parser, coverage=True, gtf=True, bed=False,
                  editing_islands=True, names=True, alignment=True, genome=True, region=False):
    """ This function stores basic argparse arguments used in almost every other function.
    """

    if coverage:
        parser.add_argument(
            "--coverage",
            type=str,
            nargs='+',
            default=None,
            help=coverage_message
        )

    if gtf:
        parser.add_argument(
            "--gtf",
            type=str,
            help=gtf_help_message
        )

    if bed:
        parser.add_argument(
            "--bed",
            type=str,
            help=gtf_help_message
        )

    if region:
        parser.add_argument(
            "--region",
            type=str,
            help=region_message
        )

    if editing_islands:
        parser.add_argument(
            "--islands",
            type=str,
            help='A bed file containing locations of editing islands.'
        )

    if names:
        parser.add_argument(
            "--names",
            type=str,
            nargs='+',
            help='Replace the file names in output with these names.'
        )

    if alignment:
        parser.add_argument(
            "--alignment",
            nargs='+',
            type=str,
            help=alignment_help_string
        )

    if genome:
        parser.add_argument(
            "--genome",
            type=str,
            help=''
        )

    vcf_params(parser)


def island_params(parser):
    """

    :param parser:
    :return:
    """
    min_samples_default = 5
    default_epsilon = 50
    min_island_length_default_value = min_samples_default * 2
    default_pad_len = 3
    vcf_params(parser)

    parser.add_argument(
        '--epsilon',
        type=float,
        default=default_epsilon,
        help='Maximum distance between two sites to considered in the same neighborhood. Default %s' % default_epsilon
    )

    parser.add_argument(
        '--pad-length',
        type=float,
        default=default_pad_len,
        help='Expand islands start and end bounds by a given integer. Default %s' % default_pad_len
    )

    parser.add_argument(
        '--min-samples',
        type=int,
        default=min_samples_default,
        help='Minimum samples for a neighborhood to be considered a core point. Default %s' % min_samples_default
    )

    parser.add_argument(
        "--min-length",
        type=int,
        default=min_island_length_default_value,
        help='Minimum editing island length. %s' % min_island_length_default_value
    )


def build_grouped_sample_data_structure(list_of_grouped_samples, delimiter=","):
    """ Build an ordered nested data structure of groups with samples files contained within.

    :param list_of_grouped_samples:
    :param delimiter:
    :return:
    """
    return [group.split(delimiter) for group in list_of_grouped_samples]


