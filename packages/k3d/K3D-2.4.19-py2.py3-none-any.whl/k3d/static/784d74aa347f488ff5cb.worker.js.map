{"version":3,"sources":["webpack:///784d74aa347f488ff5cb.worker.js","webpack:///webpack/bootstrap 784d74aa347f488ff5cb","webpack:///./src/core/lib/helpers/voxelMeshGenerator_old.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","generateCulledVoxelMesh","voxels","colorMap","chunkSize","voxelSize","offsets","x","y","z","ending","vertices","colors","width","height","length","quadIndex","Math","min","color","makeQuad","prepareColor","voxel","colorIndex","points","index","onmessage","event","data","postMessage"],"mappings":"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","file":"784d74aa347f488ff5cb.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n//jshint maxstatements:false, maxcomplexity:false, maxdepth:false\r\n//Performance reason\r\n\r\n\r\n\r\n/**\r\n * Generate greedy voxel mesh\r\n * @method generateGreedyVoxelMesh\r\n * @memberof K3D.Helpers\r\n * @param {Array} voxels\r\n * @param {Array} colorMap\r\n * @param {Object} chunkSize\r\n * @param {Object} voxelSize\r\n * @param {Object} offsets\r\n * @return {Object} with two properties - vertices and colors\r\n */\r\nfunction generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n    var vertices = [],\r\n        colors = [],\r\n        quadIndex = 0,\r\n        width = voxelSize.width,\r\n        height = voxelSize.height,\r\n        length = voxelSize.length,\r\n        dims = [width, height, length],\r\n        mask = new Int32Array(Math.max(width, height, length) * Math.max(width, height, length)),\r\n        d,\r\n        x, q,\r\n        u, v,\r\n        a, b,\r\n        i, j, k,\r\n        w, h, l,\r\n        du, dv,\r\n        n, c,\r\n        ending = [\r\n            Math.min(offsets.x + chunkSize, width),\r\n            Math.min(offsets.y + chunkSize, height),\r\n            Math.min(offsets.z + chunkSize, length)\r\n        ];\r\n\r\n    function prepareVertices(x, du, dv) {\r\n        // Performance over readability\r\n        return [\r\n            [x[0] / width, x[1] / height, x[2] / length],\r\n            [(x[0] + dv[0]) / width, (x[1] + dv[1]) / height, (x[2] + dv[2]) / length],\r\n            [(x[0] + du[0] + dv[0]) / width, (x[1] + du[1] + dv[1]) / height, (x[2] + du[2] + dv[2]) / length],\r\n            [(x[0] + du[0]) / width, (x[1] + du[1]) / height, (x[2] + du[2]) / length]\r\n        ];\r\n    }\r\n\r\n    function getVoxel(i, j, k) {\r\n        return voxels[i + width * (j + height * k)];\r\n    }\r\n\r\n    function computerHeight(w, c, j, n, u, v, ending, mask) {\r\n        var h, k;\r\n\r\n        for (h = 1; j + h < ending[v]; h++) {\r\n            for (k = 0; k < w; k++) {\r\n                if (c !== mask[n + k + h * (ending[u] - offsets[u])]) {\r\n                    return h;\r\n                }\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    offsets = [offsets.x, offsets.y, offsets.z];\r\n\r\n    //Sweep over 3-axes\r\n    for (d = 0; d < 3; d++) {\r\n        x = [0, 0, 0];\r\n        q = [0, 0, 0];\r\n        u = (d + 1) % 3;\r\n        v = (d + 2) % 3;\r\n\r\n        q[d] = 1;\r\n\r\n        for (x[d] = -1 + offsets[d]; x[d] < ending[d];) {\r\n\r\n            //Compute mask\r\n            for (x[v] = offsets[v], n = 0; x[v] < ending[v]; x[v]++) {\r\n                for (x[u] = offsets[u]; x[u] < ending[u]; x[u]++, n++) {\r\n\r\n                    a = (0 <= x[d] ? getVoxel(x[0], x[1], x[2]) : null);\r\n                    b = (x[d] < dims[d] - 1 ? getVoxel(x[0] + q[0], x[1] + q[1], x[2] + q[2]) : null);\r\n\r\n                    if (a === b || (a > 0 && b > 0)) {\r\n                        mask[n] = 0;\r\n                    } else if (!!a) {\r\n                        mask[n] = a;\r\n                    } else {\r\n                        mask[n] = -b;\r\n                    }\r\n                }\r\n            }\r\n\r\n            x[d]++;\r\n\r\n            //Generate mesh for mask using lexicographic ordering\r\n            n = 0;\r\n\r\n            for (j = offsets[v]; j < ending[v]; j++) {\r\n                for (i = offsets[u]; i < ending[u];) {\r\n\r\n                    c = mask[n];\r\n\r\n                    if (!!c) {\r\n                        //Compute width\r\n                        w = 1;\r\n                        while (c === mask[n + w] && i + w < ending[u]) {\r\n                            w++;\r\n                        }\r\n\r\n                        //Compute height\r\n                        h = computerHeight(w, c, j, n, u, v, ending, mask);\r\n\r\n                        //Add quad\r\n                        x[u] = i;\r\n                        x[v] = j;\r\n\r\n                        du = [0, 0, 0];\r\n                        dv = [0, 0, 0];\r\n\r\n                        if (c > 0) {\r\n                            dv[v] = h;\r\n                            du[u] = w;\r\n                        } else {\r\n                            c = -c;\r\n                            du[v] = h;\r\n                            dv[u] = w;\r\n                        }\r\n\r\n                        makeQuad(\r\n                            prepareVertices(x, du, dv),\r\n                            vertices,\r\n                            colors,\r\n                            prepareColor(colorMap, c),\r\n                            quadIndex++\r\n                        );\r\n\r\n                        //Zero-out mask\r\n                        for (l = 0; l < h; l++) {\r\n                            for (k = 0; k < w; k++) {\r\n                                mask[n + k + l * (ending[u] - offsets[u])] = 0;\r\n                            }\r\n                        }\r\n\r\n                        i += w;\r\n                        n += w;\r\n                    } else {\r\n                        i++;\r\n                        n++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        colors: colors,\r\n        offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n    };\r\n}\r\n\r\n/**\r\n * Generate culled voxel mesh\r\n * @method generateCulledVoxelMesh\r\n * @memberof K3D.Helpers\r\n * @param {Array} voxels\r\n * @param {Array} colorMap\r\n * @param {Object} chunkSize\r\n * @param {Object} voxelSize\r\n * @param {Object} offsets\r\n * @return {Object} with two properties - vertices and colors\r\n */\r\nfunction generateCulledVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n    var x, y, z, i,\r\n        vertices = [],\r\n        colors = [],\r\n        ending,\r\n        width = voxelSize.width,\r\n        height = voxelSize.height,\r\n        length = voxelSize.length,\r\n        quadIndex = 0;\r\n\r\n    function prepareVertices(x, y, z) {\r\n        // Performance over readability\r\n        return [\r\n            [(x + 1) / width, (y + 1) / height, (z + 1) / length],\r\n            [x / width, (y + 1) / height, (z + 1) / length],\r\n            [x / width, y / height, (z + 1) / length],\r\n            [(x + 1) / width, y / height, (z + 1) / length],\r\n            [(x + 1) / width, (y + 1) / height, z / length],\r\n            [x / width, (y + 1) / height, z / length],\r\n            [x / width, y / height, z / length],\r\n            [(x + 1) / width, y / height, z / length]\r\n        ];\r\n    }\r\n\r\n    function processBox(p, color, x, y, z, i) {\r\n        /*\r\n         * ASCII Art - vertices index in cube :D\r\n         *\r\n         *   5____4\r\n         *  1/___0/|\r\n         *  | 6__|_7\r\n         *  2/___3/\r\n         *\r\n         */\r\n\r\n        if (z === length - 1 || voxels[i + width * height] === 0) {\r\n            makeQuad([p[1], p[0], p[3], p[2]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (x === width - 1 || voxels[i + 1] === 0) {\r\n            makeQuad([p[0], p[4], p[7], p[3]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (z === 0 || voxels[i - width * height] === 0) {\r\n            makeQuad([p[4], p[5], p[6], p[7]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (x === 0 || voxels[i - 1] === 0) {\r\n            makeQuad([p[5], p[1], p[2], p[6]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (y === height - 1 || voxels[i + width] === 0) {\r\n            makeQuad([p[5], p[4], p[0], p[1]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (y === 0 || voxels[i - width] === 0) {\r\n            makeQuad([p[2], p[3], p[7], p[6]], vertices, colors, color, quadIndex++);\r\n        }\r\n    }\r\n\r\n    ending = {\r\n        x: Math.min(offsets.x + chunkSize, width),\r\n        y: Math.min(offsets.y + chunkSize, height),\r\n        z: Math.min(offsets.z + chunkSize, length)\r\n    };\r\n\r\n    for (z = offsets.z; z < ending.z; z++) {\r\n        for (y = offsets.y; y < ending.y; y++) {\r\n            for (x = offsets.x; x < ending.x; x++) {\r\n\r\n                i = x + width * (y + height * z);\r\n\r\n                if (voxels[i] !== 0) {\r\n                    processBox(\r\n                        prepareVertices(x, y, z),\r\n                        prepareColor(colorMap, voxels[i]),\r\n                        x, y, z, i\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        colors: colors,\r\n        offsets: offsets\r\n    };\r\n}\r\n\r\nfunction prepareColor(colorMap, voxel) {\r\n    var colorIndex = (voxel - 1) * 3;\r\n\r\n    return [colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2]];\r\n}\r\n\r\nfunction makeQuad(points, vertices, colors, color, quadIndex) {\r\n    var index = quadIndex * 18, i;\r\n\r\n    vertices[index] = points[0][0];\r\n    vertices[index + 1] = points[0][1];\r\n    vertices[index + 2] = points[0][2];\r\n    vertices[index + 3] = points[3][0];\r\n    vertices[index + 4] = points[3][1];\r\n    vertices[index + 5] = points[3][2];\r\n    vertices[index + 6] = points[1][0];\r\n    vertices[index + 7] = points[1][1];\r\n    vertices[index + 8] = points[1][2];\r\n\r\n    vertices[index + 9] = points[1][0];\r\n    vertices[index + 10] = points[1][1];\r\n    vertices[index + 11] = points[1][2];\r\n    vertices[index + 12] = points[3][0];\r\n    vertices[index + 13] = points[3][1];\r\n    vertices[index + 14] = points[3][2];\r\n    vertices[index + 15] = points[2][0];\r\n    vertices[index + 16] = points[2][1];\r\n    vertices[index + 17] = points[2][2];\r\n\r\n    for (i = 0; i < 18; i += 3) {\r\n        colors[index + i] = color[0];\r\n        colors[index + i + 1] = color[1];\r\n        colors[index + i + 2] = color[2];\r\n    }\r\n}\r\n\r\nonmessage = function (event) {\r\n    var data = event.data;\r\n    // postMessage(generateGreedyVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n    postMessage(generateCulledVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 784d74aa347f488ff5cb.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 784d74aa347f488ff5cb","//jshint maxstatements:false, maxcomplexity:false, maxdepth:false\r\n//Performance reason\r\n\r\n'use strict';\r\n\r\n/**\r\n * Generate greedy voxel mesh\r\n * @method generateGreedyVoxelMesh\r\n * @memberof K3D.Helpers\r\n * @param {Array} voxels\r\n * @param {Array} colorMap\r\n * @param {Object} chunkSize\r\n * @param {Object} voxelSize\r\n * @param {Object} offsets\r\n * @return {Object} with two properties - vertices and colors\r\n */\r\nfunction generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n    var vertices = [],\r\n        colors = [],\r\n        quadIndex = 0,\r\n        width = voxelSize.width,\r\n        height = voxelSize.height,\r\n        length = voxelSize.length,\r\n        dims = [width, height, length],\r\n        mask = new Int32Array(Math.max(width, height, length) * Math.max(width, height, length)),\r\n        d,\r\n        x, q,\r\n        u, v,\r\n        a, b,\r\n        i, j, k,\r\n        w, h, l,\r\n        du, dv,\r\n        n, c,\r\n        ending = [\r\n            Math.min(offsets.x + chunkSize, width),\r\n            Math.min(offsets.y + chunkSize, height),\r\n            Math.min(offsets.z + chunkSize, length)\r\n        ];\r\n\r\n    function prepareVertices(x, du, dv) {\r\n        // Performance over readability\r\n        return [\r\n            [x[0] / width, x[1] / height, x[2] / length],\r\n            [(x[0] + dv[0]) / width, (x[1] + dv[1]) / height, (x[2] + dv[2]) / length],\r\n            [(x[0] + du[0] + dv[0]) / width, (x[1] + du[1] + dv[1]) / height, (x[2] + du[2] + dv[2]) / length],\r\n            [(x[0] + du[0]) / width, (x[1] + du[1]) / height, (x[2] + du[2]) / length]\r\n        ];\r\n    }\r\n\r\n    function getVoxel(i, j, k) {\r\n        return voxels[i + width * (j + height * k)];\r\n    }\r\n\r\n    function computerHeight(w, c, j, n, u, v, ending, mask) {\r\n        var h, k;\r\n\r\n        for (h = 1; j + h < ending[v]; h++) {\r\n            for (k = 0; k < w; k++) {\r\n                if (c !== mask[n + k + h * (ending[u] - offsets[u])]) {\r\n                    return h;\r\n                }\r\n            }\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    offsets = [offsets.x, offsets.y, offsets.z];\r\n\r\n    //Sweep over 3-axes\r\n    for (d = 0; d < 3; d++) {\r\n        x = [0, 0, 0];\r\n        q = [0, 0, 0];\r\n        u = (d + 1) % 3;\r\n        v = (d + 2) % 3;\r\n\r\n        q[d] = 1;\r\n\r\n        for (x[d] = -1 + offsets[d]; x[d] < ending[d];) {\r\n\r\n            //Compute mask\r\n            for (x[v] = offsets[v], n = 0; x[v] < ending[v]; x[v]++) {\r\n                for (x[u] = offsets[u]; x[u] < ending[u]; x[u]++, n++) {\r\n\r\n                    a = (0 <= x[d] ? getVoxel(x[0], x[1], x[2]) : null);\r\n                    b = (x[d] < dims[d] - 1 ? getVoxel(x[0] + q[0], x[1] + q[1], x[2] + q[2]) : null);\r\n\r\n                    if (a === b || (a > 0 && b > 0)) {\r\n                        mask[n] = 0;\r\n                    } else if (!!a) {\r\n                        mask[n] = a;\r\n                    } else {\r\n                        mask[n] = -b;\r\n                    }\r\n                }\r\n            }\r\n\r\n            x[d]++;\r\n\r\n            //Generate mesh for mask using lexicographic ordering\r\n            n = 0;\r\n\r\n            for (j = offsets[v]; j < ending[v]; j++) {\r\n                for (i = offsets[u]; i < ending[u];) {\r\n\r\n                    c = mask[n];\r\n\r\n                    if (!!c) {\r\n                        //Compute width\r\n                        w = 1;\r\n                        while (c === mask[n + w] && i + w < ending[u]) {\r\n                            w++;\r\n                        }\r\n\r\n                        //Compute height\r\n                        h = computerHeight(w, c, j, n, u, v, ending, mask);\r\n\r\n                        //Add quad\r\n                        x[u] = i;\r\n                        x[v] = j;\r\n\r\n                        du = [0, 0, 0];\r\n                        dv = [0, 0, 0];\r\n\r\n                        if (c > 0) {\r\n                            dv[v] = h;\r\n                            du[u] = w;\r\n                        } else {\r\n                            c = -c;\r\n                            du[v] = h;\r\n                            dv[u] = w;\r\n                        }\r\n\r\n                        makeQuad(\r\n                            prepareVertices(x, du, dv),\r\n                            vertices,\r\n                            colors,\r\n                            prepareColor(colorMap, c),\r\n                            quadIndex++\r\n                        );\r\n\r\n                        //Zero-out mask\r\n                        for (l = 0; l < h; l++) {\r\n                            for (k = 0; k < w; k++) {\r\n                                mask[n + k + l * (ending[u] - offsets[u])] = 0;\r\n                            }\r\n                        }\r\n\r\n                        i += w;\r\n                        n += w;\r\n                    } else {\r\n                        i++;\r\n                        n++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        colors: colors,\r\n        offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n    };\r\n}\r\n\r\n/**\r\n * Generate culled voxel mesh\r\n * @method generateCulledVoxelMesh\r\n * @memberof K3D.Helpers\r\n * @param {Array} voxels\r\n * @param {Array} colorMap\r\n * @param {Object} chunkSize\r\n * @param {Object} voxelSize\r\n * @param {Object} offsets\r\n * @return {Object} with two properties - vertices and colors\r\n */\r\nfunction generateCulledVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n    var x, y, z, i,\r\n        vertices = [],\r\n        colors = [],\r\n        ending,\r\n        width = voxelSize.width,\r\n        height = voxelSize.height,\r\n        length = voxelSize.length,\r\n        quadIndex = 0;\r\n\r\n    function prepareVertices(x, y, z) {\r\n        // Performance over readability\r\n        return [\r\n            [(x + 1) / width, (y + 1) / height, (z + 1) / length],\r\n            [x / width, (y + 1) / height, (z + 1) / length],\r\n            [x / width, y / height, (z + 1) / length],\r\n            [(x + 1) / width, y / height, (z + 1) / length],\r\n            [(x + 1) / width, (y + 1) / height, z / length],\r\n            [x / width, (y + 1) / height, z / length],\r\n            [x / width, y / height, z / length],\r\n            [(x + 1) / width, y / height, z / length]\r\n        ];\r\n    }\r\n\r\n    function processBox(p, color, x, y, z, i) {\r\n        /*\r\n         * ASCII Art - vertices index in cube :D\r\n         *\r\n         *   5____4\r\n         *  1/___0/|\r\n         *  | 6__|_7\r\n         *  2/___3/\r\n         *\r\n         */\r\n\r\n        if (z === length - 1 || voxels[i + width * height] === 0) {\r\n            makeQuad([p[1], p[0], p[3], p[2]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (x === width - 1 || voxels[i + 1] === 0) {\r\n            makeQuad([p[0], p[4], p[7], p[3]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (z === 0 || voxels[i - width * height] === 0) {\r\n            makeQuad([p[4], p[5], p[6], p[7]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (x === 0 || voxels[i - 1] === 0) {\r\n            makeQuad([p[5], p[1], p[2], p[6]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (y === height - 1 || voxels[i + width] === 0) {\r\n            makeQuad([p[5], p[4], p[0], p[1]], vertices, colors, color, quadIndex++);\r\n        }\r\n\r\n        if (y === 0 || voxels[i - width] === 0) {\r\n            makeQuad([p[2], p[3], p[7], p[6]], vertices, colors, color, quadIndex++);\r\n        }\r\n    }\r\n\r\n    ending = {\r\n        x: Math.min(offsets.x + chunkSize, width),\r\n        y: Math.min(offsets.y + chunkSize, height),\r\n        z: Math.min(offsets.z + chunkSize, length)\r\n    };\r\n\r\n    for (z = offsets.z; z < ending.z; z++) {\r\n        for (y = offsets.y; y < ending.y; y++) {\r\n            for (x = offsets.x; x < ending.x; x++) {\r\n\r\n                i = x + width * (y + height * z);\r\n\r\n                if (voxels[i] !== 0) {\r\n                    processBox(\r\n                        prepareVertices(x, y, z),\r\n                        prepareColor(colorMap, voxels[i]),\r\n                        x, y, z, i\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        colors: colors,\r\n        offsets: offsets\r\n    };\r\n}\r\n\r\nfunction prepareColor(colorMap, voxel) {\r\n    var colorIndex = (voxel - 1) * 3;\r\n\r\n    return [colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2]];\r\n}\r\n\r\nfunction makeQuad(points, vertices, colors, color, quadIndex) {\r\n    var index = quadIndex * 18, i;\r\n\r\n    vertices[index] = points[0][0];\r\n    vertices[index + 1] = points[0][1];\r\n    vertices[index + 2] = points[0][2];\r\n    vertices[index + 3] = points[3][0];\r\n    vertices[index + 4] = points[3][1];\r\n    vertices[index + 5] = points[3][2];\r\n    vertices[index + 6] = points[1][0];\r\n    vertices[index + 7] = points[1][1];\r\n    vertices[index + 8] = points[1][2];\r\n\r\n    vertices[index + 9] = points[1][0];\r\n    vertices[index + 10] = points[1][1];\r\n    vertices[index + 11] = points[1][2];\r\n    vertices[index + 12] = points[3][0];\r\n    vertices[index + 13] = points[3][1];\r\n    vertices[index + 14] = points[3][2];\r\n    vertices[index + 15] = points[2][0];\r\n    vertices[index + 16] = points[2][1];\r\n    vertices[index + 17] = points[2][2];\r\n\r\n    for (i = 0; i < 18; i += 3) {\r\n        colors[index + i] = color[0];\r\n        colors[index + i + 1] = color[1];\r\n        colors[index + i + 2] = color[2];\r\n    }\r\n}\r\n\r\nonmessage = function (event) {\r\n    var data = event.data;\r\n    // postMessage(generateGreedyVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n    postMessage(generateCulledVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/lib/helpers/voxelMeshGenerator_old.worker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}