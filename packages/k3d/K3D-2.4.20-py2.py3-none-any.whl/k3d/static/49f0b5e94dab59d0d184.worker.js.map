{"version":3,"sources":["webpack:///49f0b5e94dab59d0d184.worker.js","webpack:///webpack/bootstrap 49f0b5e94dab59d0d184","webpack:///./src/core/lib/helpers/voxelMeshGenerator.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","generateGreedyVoxelMesh","voxels","colorMap","chunkSize","voxelSize","offsets","mask","Int32Array","vertices","faces","dims","width","height","length","dimsX","dimsY","dimsXY","colors","j","k","w","W","h","qdimsX","qdimsXY","xd","u","v","x","q","du","dv","dimsD","dimsU","dimsV","ending","Math","min","y","z","a","b","vertex_count","push","onmessage","event","data","postMessage"],"mappings":"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","file":"49f0b5e94dab59d0d184.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n//jshint maxstatements:false, maxcomplexity:false, maxdepth:false\r\n//Performance reason\r\n\r\n\r\n\r\nfunction generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n\r\n    var mask = new Int32Array(4096);\r\n\r\n    var vertices = [], faces = [], dims = [voxelSize.width, voxelSize.height, voxelSize.length]\r\n        , dimsX = dims[0]\r\n        , dimsY = dims[1]\r\n        , dimsXY = dimsX * dimsY\r\n        , colors = [];\r\n\r\n    //Sweep over 3-axes\r\n    for (var d = 0; d < 3; ++d) {\r\n        var i, j, k, l, w, W, h, n, c\r\n            , u = (d + 1) % 3\r\n            , v = (d + 2) % 3\r\n            , x = [0, 0, 0]\r\n            , q = [0, 0, 0]\r\n            , du = [0, 0, 0]\r\n            , dv = [0, 0, 0]\r\n            , dimsD = dims[d]\r\n            , dimsU = dims[u]\r\n            , dimsV = dims[v]\r\n            , qdimsX, qdimsXY\r\n            , xd,\r\n            ending = [\r\n                Math.min(offsets.x + chunkSize, voxelSize.width),\r\n                Math.min(offsets.y + chunkSize, voxelSize.height),\r\n                Math.min(offsets.z + chunkSize, voxelSize.length)\r\n            ];\r\n\r\n        if (mask.length < dimsU * dimsV) {\r\n            mask = new Int32Array(dimsU * dimsV);\r\n        }\r\n\r\n        q[d] = 1;\r\n        x[d] = -1;\r\n\r\n        qdimsX = dimsX * q[1];\r\n        qdimsXY = dimsXY * q[2];\r\n\r\n        // Compute mask\r\n        while (x[d] < dimsD) {\r\n            xd = x[d];\r\n            n = 0;\r\n\r\n            for (x[v] = offsets[v]; x[v] < ending[v]; ++x[v]) {\r\n                for (x[u] = offsets[u]; x[u] < ending[u]; ++x[u], ++n) {\r\n                    var a = xd >= 0 && voxels[x[0] + dimsX * x[1] + dimsXY * x[2]]\r\n                        , b = xd < dimsD - 1 && voxels[x[0] + q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]\r\n                    if (a ? b : !b) {\r\n                        mask[n] = 0;\r\n                        continue;\r\n                    }\r\n                    mask[n] = a ? a : -b;\r\n                }\r\n            }\r\n\r\n            ++x[d];\r\n\r\n            // Generate mesh for mask using lexicographic ordering\r\n            n = 0;\r\n            for (j = 0; j < dimsV; ++j) {\r\n                for (i = 0; i < dimsU;) {\r\n                    c = mask[n];\r\n                    if (!c) {\r\n                        i++;\r\n                        n++;\r\n                        continue;\r\n                    }\r\n\r\n                    //Compute width\r\n                    w = 1;\r\n                    while (c === mask[n + w] && i + w < dimsU) w++;\r\n\r\n                    //Compute height (this is slightly awkward)\r\n                    for (h = 1; j + h < dimsV; ++h) {\r\n                        k = 0;\r\n                        while (k < w && c === mask[n + k + h * dimsU]) k++;\r\n                        if (k < w) break;\r\n                    }\r\n\r\n                    // Add quad\r\n                    // The du/dv arrays are reused/reset\r\n                    // for each iteration.\r\n                    du[d] = 0;\r\n                    dv[d] = 0;\r\n                    x[u] = i;\r\n                    x[v] = j;\r\n\r\n                    if (c > 0) {\r\n                        dv[v] = h;\r\n                        dv[u] = 0;\r\n                        du[u] = w;\r\n                        du[v] = 0;\r\n                    } else {\r\n                        c = -c;\r\n                        du[v] = h;\r\n                        du[u] = 0;\r\n                        dv[u] = w;\r\n                        dv[v] = 0;\r\n                    }\r\n                    var vertex_count = vertices.length;\r\n\r\n                    vertices.push([x[0], x[1], x[2]]);\r\n                    vertices.push([x[0] + du[0], x[1] + du[1], x[2] + du[2]]);\r\n                    vertices.push([x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2]]);\r\n                    vertices.push([x[0] + dv[0], x[1] + dv[1], x[2] + dv[2]]);\r\n\r\n                    for (l = 0; l < 4; l++) {\r\n                        colors.push(colorMap[c * 3]);\r\n                        colors.push(colorMap[c * 3 + 1]);\r\n                        colors.push(colorMap[c * 3 + 2]);\r\n                    }\r\n\r\n                    faces.push([vertex_count, vertex_count + 1, vertex_count + 2, vertex_count + 3, c]);\r\n\r\n                    //Zero-out mask\r\n                    W = n + w;\r\n                    for (l = 0; l < h; ++l) {\r\n                        for (k = n; k < W; ++k) {\r\n                            mask[k + l * dimsU] = 0;\r\n                        }\r\n                    }\r\n\r\n                    //Increment counters and continue\r\n                    i += w;\r\n                    n += w;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        faces: faces,\r\n        colors: colors,\r\n        offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n    };\r\n}\r\n\r\n//\r\n// /**\r\n//  * Generate greedy voxel mesh\r\n//  * @method generateGreedyVoxelMesh\r\n//  * @memberof K3D.Helpers\r\n//  * @param {Array} voxels\r\n//  * @param {Array} colorMap\r\n//  * @param {Object} chunkSize\r\n//  * @param {Object} voxelSize\r\n//  * @param {Object} offsets\r\n//  * @return {Object} with two properties - vertices and colors\r\n//  */\r\n// function generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n//     var vertices = [],\r\n//         colors = [],\r\n//         quadIndex = 0,\r\n//         width = voxelSize.width,\r\n//         height = voxelSize.height,\r\n//         length = voxelSize.length,\r\n//         dims = [width, height, length],\r\n//         mask = new Int32Array(Math.max(width, height, length) * Math.max(width, height, length)),\r\n//         d,\r\n//         x, q,\r\n//         u, v,\r\n//         a, b,\r\n//         i, j, k,\r\n//         w, h, l,\r\n//         du, dv,\r\n//         n, c,\r\n//         ending = [\r\n//             Math.min(offsets.x + chunkSize, width),\r\n//             Math.min(offsets.y + chunkSize, height),\r\n//             Math.min(offsets.z + chunkSize, length)\r\n//         ];\r\n//\r\n//     function prepareVertices(x, du, dv) {\r\n//         // Performance over readability\r\n//         return [\r\n//             [x[0] / width, x[1] / height, x[2] / length],\r\n//             [(x[0] + dv[0]) / width, (x[1] + dv[1]) / height, (x[2] + dv[2]) / length],\r\n//             [(x[0] + du[0] + dv[0]) / width, (x[1] + du[1] + dv[1]) / height, (x[2] + du[2] + dv[2]) / length],\r\n//             [(x[0] + du[0]) / width, (x[1] + du[1]) / height, (x[2] + du[2]) / length]\r\n//         ];\r\n//     }\r\n//\r\n//     function getVoxel(i, j, k) {\r\n//         return voxels[i + width * (j + height * k)];\r\n//     }\r\n//\r\n//     function computerHeight(w, c, j, n, u, v, ending, mask) {\r\n//         var h, k;\r\n//\r\n//         for (h = 1; j + h < ending[v]; h++) {\r\n//             for (k = 0; k < w; k++) {\r\n//                 if (c !== mask[n + k + h * (ending[u] - offsets[u])]) {\r\n//                     return h;\r\n//                 }\r\n//             }\r\n//         }\r\n//\r\n//         return h;\r\n//     }\r\n//\r\n//     offsets = [offsets.x, offsets.y, offsets.z];\r\n//\r\n//     //Sweep over 3-axes\r\n//     for (d = 0; d < 3; d++) {\r\n//         x = [0, 0, 0];\r\n//         q = [0, 0, 0];\r\n//         u = (d + 1) % 3;\r\n//         v = (d + 2) % 3;\r\n//\r\n//         q[d] = 1;\r\n//\r\n//         for (x[d] = -1 + offsets[d]; x[d] < ending[d];) {\r\n//\r\n//             //Compute mask\r\n//             for (x[v] = offsets[v], n = 0; x[v] < ending[v]; x[v]++) {\r\n//                 for (x[u] = offsets[u]; x[u] < ending[u]; x[u]++, n++) {\r\n//\r\n//                     a = (0 <= x[d] ? getVoxel(x[0], x[1], x[2]) : null);\r\n//                     b = (x[d] < dims[d] - 1 ? getVoxel(x[0] + q[0], x[1] + q[1], x[2] + q[2]) : null);\r\n//\r\n//                     if (a === b || (a > 0 && b > 0)) {\r\n//                         mask[n] = 0;\r\n//                     } else if (!!a) {\r\n//                         mask[n] = a;\r\n//                     } else {\r\n//                         mask[n] = -b;\r\n//                     }\r\n//                 }\r\n//             }\r\n//\r\n//             x[d]++;\r\n//\r\n//             //Generate mesh for mask using lexicographic ordering\r\n//             n = 0;\r\n//\r\n//             for (j = offsets[v]; j < ending[v]; j++) {\r\n//                 for (i = offsets[u]; i < ending[u];) {\r\n//\r\n//                     c = mask[n];\r\n//\r\n//                     if (!!c) {\r\n//                         //Compute width\r\n//                         w = 1;\r\n//                         while (c === mask[n + w] && i + w < ending[u]) {\r\n//                             w++;\r\n//                         }\r\n//\r\n//                         //Compute height\r\n//                         h = computerHeight(w, c, j, n, u, v, ending, mask);\r\n//\r\n//                         //Add quad\r\n//                         x[u] = i;\r\n//                         x[v] = j;\r\n//\r\n//                         du = [0, 0, 0];\r\n//                         dv = [0, 0, 0];\r\n//\r\n//                         if (c > 0) {\r\n//                             dv[v] = h;\r\n//                             du[u] = w;\r\n//                         } else {\r\n//                             c = -c;\r\n//                             du[v] = h;\r\n//                             dv[u] = w;\r\n//                         }\r\n//\r\n//                         makeQuad(\r\n//                             prepareVertices(x, du, dv),\r\n//                             vertices,\r\n//                             colors,\r\n//                             prepareColor(colorMap, c),\r\n//                             quadIndex++\r\n//                         );\r\n//\r\n//                         //Zero-out mask\r\n//                         for (l = 0; l < h; l++) {\r\n//                             for (k = 0; k < w; k++) {\r\n//                                 mask[n + k + l * (ending[u] - offsets[u])] = 0;\r\n//                             }\r\n//                         }\r\n//\r\n//                         i += w;\r\n//                         n += w;\r\n//                     } else {\r\n//                         i++;\r\n//                         n++;\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n//\r\n//     return {\r\n//         vertices: vertices,\r\n//         colors: colors,\r\n//         offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n//     };\r\n// }\r\n//\r\n//\r\n// function prepareColor(colorMap, voxel) {\r\n//     var colorIndex = (voxel - 1) * 3;\r\n//\r\n//     return [colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2]];\r\n// }\r\n//\r\n// function makeQuad(points, vertices, colors, color, quadIndex) {\r\n//     var index = quadIndex * 18, i;\r\n//\r\n//     vertices[index] = points[0][0];\r\n//     vertices[index + 1] = points[0][1];\r\n//     vertices[index + 2] = points[0][2];\r\n//     vertices[index + 3] = points[3][0];\r\n//     vertices[index + 4] = points[3][1];\r\n//     vertices[index + 5] = points[3][2];\r\n//     vertices[index + 6] = points[1][0];\r\n//     vertices[index + 7] = points[1][1];\r\n//     vertices[index + 8] = points[1][2];\r\n//\r\n//     vertices[index + 9] = points[1][0];\r\n//     vertices[index + 10] = points[1][1];\r\n//     vertices[index + 11] = points[1][2];\r\n//     vertices[index + 12] = points[3][0];\r\n//     vertices[index + 13] = points[3][1];\r\n//     vertices[index + 14] = points[3][2];\r\n//     vertices[index + 15] = points[2][0];\r\n//     vertices[index + 16] = points[2][1];\r\n//     vertices[index + 17] = points[2][2];\r\n//\r\n//     for (i = 0; i < 18; i += 3) {\r\n//         colors[index + i] = color[0];\r\n//         colors[index + i + 1] = color[1];\r\n//         colors[index + i + 2] = color[2];\r\n//     }\r\n// }\r\n\r\nonmessage = function (event) {\r\n    var data = event.data;\r\n\r\n    postMessage(generateGreedyVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 49f0b5e94dab59d0d184.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 49f0b5e94dab59d0d184","//jshint maxstatements:false, maxcomplexity:false, maxdepth:false\r\n//Performance reason\r\n\r\n'use strict';\r\n\r\nfunction generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n\r\n    var mask = new Int32Array(4096);\r\n\r\n    var vertices = [], faces = [], dims = [voxelSize.width, voxelSize.height, voxelSize.length]\r\n        , dimsX = dims[0]\r\n        , dimsY = dims[1]\r\n        , dimsXY = dimsX * dimsY\r\n        , colors = [];\r\n\r\n    //Sweep over 3-axes\r\n    for (var d = 0; d < 3; ++d) {\r\n        var i, j, k, l, w, W, h, n, c\r\n            , u = (d + 1) % 3\r\n            , v = (d + 2) % 3\r\n            , x = [0, 0, 0]\r\n            , q = [0, 0, 0]\r\n            , du = [0, 0, 0]\r\n            , dv = [0, 0, 0]\r\n            , dimsD = dims[d]\r\n            , dimsU = dims[u]\r\n            , dimsV = dims[v]\r\n            , qdimsX, qdimsXY\r\n            , xd,\r\n            ending = [\r\n                Math.min(offsets.x + chunkSize, voxelSize.width),\r\n                Math.min(offsets.y + chunkSize, voxelSize.height),\r\n                Math.min(offsets.z + chunkSize, voxelSize.length)\r\n            ];\r\n\r\n        if (mask.length < dimsU * dimsV) {\r\n            mask = new Int32Array(dimsU * dimsV);\r\n        }\r\n\r\n        q[d] = 1;\r\n        x[d] = -1;\r\n\r\n        qdimsX = dimsX * q[1];\r\n        qdimsXY = dimsXY * q[2];\r\n\r\n        // Compute mask\r\n        while (x[d] < dimsD) {\r\n            xd = x[d];\r\n            n = 0;\r\n\r\n            for (x[v] = offsets[v]; x[v] < ending[v]; ++x[v]) {\r\n                for (x[u] = offsets[u]; x[u] < ending[u]; ++x[u], ++n) {\r\n                    var a = xd >= 0 && voxels[x[0] + dimsX * x[1] + dimsXY * x[2]]\r\n                        , b = xd < dimsD - 1 && voxels[x[0] + q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]\r\n                    if (a ? b : !b) {\r\n                        mask[n] = 0;\r\n                        continue;\r\n                    }\r\n                    mask[n] = a ? a : -b;\r\n                }\r\n            }\r\n\r\n            ++x[d];\r\n\r\n            // Generate mesh for mask using lexicographic ordering\r\n            n = 0;\r\n            for (j = 0; j < dimsV; ++j) {\r\n                for (i = 0; i < dimsU;) {\r\n                    c = mask[n];\r\n                    if (!c) {\r\n                        i++;\r\n                        n++;\r\n                        continue;\r\n                    }\r\n\r\n                    //Compute width\r\n                    w = 1;\r\n                    while (c === mask[n + w] && i + w < dimsU) w++;\r\n\r\n                    //Compute height (this is slightly awkward)\r\n                    for (h = 1; j + h < dimsV; ++h) {\r\n                        k = 0;\r\n                        while (k < w && c === mask[n + k + h * dimsU]) k++;\r\n                        if (k < w) break;\r\n                    }\r\n\r\n                    // Add quad\r\n                    // The du/dv arrays are reused/reset\r\n                    // for each iteration.\r\n                    du[d] = 0;\r\n                    dv[d] = 0;\r\n                    x[u] = i;\r\n                    x[v] = j;\r\n\r\n                    if (c > 0) {\r\n                        dv[v] = h;\r\n                        dv[u] = 0;\r\n                        du[u] = w;\r\n                        du[v] = 0;\r\n                    } else {\r\n                        c = -c;\r\n                        du[v] = h;\r\n                        du[u] = 0;\r\n                        dv[u] = w;\r\n                        dv[v] = 0;\r\n                    }\r\n                    var vertex_count = vertices.length;\r\n\r\n                    vertices.push([x[0], x[1], x[2]]);\r\n                    vertices.push([x[0] + du[0], x[1] + du[1], x[2] + du[2]]);\r\n                    vertices.push([x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2]]);\r\n                    vertices.push([x[0] + dv[0], x[1] + dv[1], x[2] + dv[2]]);\r\n\r\n                    for (l = 0; l < 4; l++) {\r\n                        colors.push(colorMap[c * 3]);\r\n                        colors.push(colorMap[c * 3 + 1]);\r\n                        colors.push(colorMap[c * 3 + 2]);\r\n                    }\r\n\r\n                    faces.push([vertex_count, vertex_count + 1, vertex_count + 2, vertex_count + 3, c]);\r\n\r\n                    //Zero-out mask\r\n                    W = n + w;\r\n                    for (l = 0; l < h; ++l) {\r\n                        for (k = n; k < W; ++k) {\r\n                            mask[k + l * dimsU] = 0;\r\n                        }\r\n                    }\r\n\r\n                    //Increment counters and continue\r\n                    i += w;\r\n                    n += w;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        vertices: vertices,\r\n        faces: faces,\r\n        colors: colors,\r\n        offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n    };\r\n}\r\n\r\n//\r\n// /**\r\n//  * Generate greedy voxel mesh\r\n//  * @method generateGreedyVoxelMesh\r\n//  * @memberof K3D.Helpers\r\n//  * @param {Array} voxels\r\n//  * @param {Array} colorMap\r\n//  * @param {Object} chunkSize\r\n//  * @param {Object} voxelSize\r\n//  * @param {Object} offsets\r\n//  * @return {Object} with two properties - vertices and colors\r\n//  */\r\n// function generateGreedyVoxelMesh(voxels, colorMap, chunkSize, voxelSize, offsets) {\r\n//     var vertices = [],\r\n//         colors = [],\r\n//         quadIndex = 0,\r\n//         width = voxelSize.width,\r\n//         height = voxelSize.height,\r\n//         length = voxelSize.length,\r\n//         dims = [width, height, length],\r\n//         mask = new Int32Array(Math.max(width, height, length) * Math.max(width, height, length)),\r\n//         d,\r\n//         x, q,\r\n//         u, v,\r\n//         a, b,\r\n//         i, j, k,\r\n//         w, h, l,\r\n//         du, dv,\r\n//         n, c,\r\n//         ending = [\r\n//             Math.min(offsets.x + chunkSize, width),\r\n//             Math.min(offsets.y + chunkSize, height),\r\n//             Math.min(offsets.z + chunkSize, length)\r\n//         ];\r\n//\r\n//     function prepareVertices(x, du, dv) {\r\n//         // Performance over readability\r\n//         return [\r\n//             [x[0] / width, x[1] / height, x[2] / length],\r\n//             [(x[0] + dv[0]) / width, (x[1] + dv[1]) / height, (x[2] + dv[2]) / length],\r\n//             [(x[0] + du[0] + dv[0]) / width, (x[1] + du[1] + dv[1]) / height, (x[2] + du[2] + dv[2]) / length],\r\n//             [(x[0] + du[0]) / width, (x[1] + du[1]) / height, (x[2] + du[2]) / length]\r\n//         ];\r\n//     }\r\n//\r\n//     function getVoxel(i, j, k) {\r\n//         return voxels[i + width * (j + height * k)];\r\n//     }\r\n//\r\n//     function computerHeight(w, c, j, n, u, v, ending, mask) {\r\n//         var h, k;\r\n//\r\n//         for (h = 1; j + h < ending[v]; h++) {\r\n//             for (k = 0; k < w; k++) {\r\n//                 if (c !== mask[n + k + h * (ending[u] - offsets[u])]) {\r\n//                     return h;\r\n//                 }\r\n//             }\r\n//         }\r\n//\r\n//         return h;\r\n//     }\r\n//\r\n//     offsets = [offsets.x, offsets.y, offsets.z];\r\n//\r\n//     //Sweep over 3-axes\r\n//     for (d = 0; d < 3; d++) {\r\n//         x = [0, 0, 0];\r\n//         q = [0, 0, 0];\r\n//         u = (d + 1) % 3;\r\n//         v = (d + 2) % 3;\r\n//\r\n//         q[d] = 1;\r\n//\r\n//         for (x[d] = -1 + offsets[d]; x[d] < ending[d];) {\r\n//\r\n//             //Compute mask\r\n//             for (x[v] = offsets[v], n = 0; x[v] < ending[v]; x[v]++) {\r\n//                 for (x[u] = offsets[u]; x[u] < ending[u]; x[u]++, n++) {\r\n//\r\n//                     a = (0 <= x[d] ? getVoxel(x[0], x[1], x[2]) : null);\r\n//                     b = (x[d] < dims[d] - 1 ? getVoxel(x[0] + q[0], x[1] + q[1], x[2] + q[2]) : null);\r\n//\r\n//                     if (a === b || (a > 0 && b > 0)) {\r\n//                         mask[n] = 0;\r\n//                     } else if (!!a) {\r\n//                         mask[n] = a;\r\n//                     } else {\r\n//                         mask[n] = -b;\r\n//                     }\r\n//                 }\r\n//             }\r\n//\r\n//             x[d]++;\r\n//\r\n//             //Generate mesh for mask using lexicographic ordering\r\n//             n = 0;\r\n//\r\n//             for (j = offsets[v]; j < ending[v]; j++) {\r\n//                 for (i = offsets[u]; i < ending[u];) {\r\n//\r\n//                     c = mask[n];\r\n//\r\n//                     if (!!c) {\r\n//                         //Compute width\r\n//                         w = 1;\r\n//                         while (c === mask[n + w] && i + w < ending[u]) {\r\n//                             w++;\r\n//                         }\r\n//\r\n//                         //Compute height\r\n//                         h = computerHeight(w, c, j, n, u, v, ending, mask);\r\n//\r\n//                         //Add quad\r\n//                         x[u] = i;\r\n//                         x[v] = j;\r\n//\r\n//                         du = [0, 0, 0];\r\n//                         dv = [0, 0, 0];\r\n//\r\n//                         if (c > 0) {\r\n//                             dv[v] = h;\r\n//                             du[u] = w;\r\n//                         } else {\r\n//                             c = -c;\r\n//                             du[v] = h;\r\n//                             dv[u] = w;\r\n//                         }\r\n//\r\n//                         makeQuad(\r\n//                             prepareVertices(x, du, dv),\r\n//                             vertices,\r\n//                             colors,\r\n//                             prepareColor(colorMap, c),\r\n//                             quadIndex++\r\n//                         );\r\n//\r\n//                         //Zero-out mask\r\n//                         for (l = 0; l < h; l++) {\r\n//                             for (k = 0; k < w; k++) {\r\n//                                 mask[n + k + l * (ending[u] - offsets[u])] = 0;\r\n//                             }\r\n//                         }\r\n//\r\n//                         i += w;\r\n//                         n += w;\r\n//                     } else {\r\n//                         i++;\r\n//                         n++;\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n//\r\n//     return {\r\n//         vertices: vertices,\r\n//         colors: colors,\r\n//         offsets: {x: offsets[0], y: offsets[1], z: offsets[2]}\r\n//     };\r\n// }\r\n//\r\n//\r\n// function prepareColor(colorMap, voxel) {\r\n//     var colorIndex = (voxel - 1) * 3;\r\n//\r\n//     return [colorMap[colorIndex], colorMap[colorIndex + 1], colorMap[colorIndex + 2]];\r\n// }\r\n//\r\n// function makeQuad(points, vertices, colors, color, quadIndex) {\r\n//     var index = quadIndex * 18, i;\r\n//\r\n//     vertices[index] = points[0][0];\r\n//     vertices[index + 1] = points[0][1];\r\n//     vertices[index + 2] = points[0][2];\r\n//     vertices[index + 3] = points[3][0];\r\n//     vertices[index + 4] = points[3][1];\r\n//     vertices[index + 5] = points[3][2];\r\n//     vertices[index + 6] = points[1][0];\r\n//     vertices[index + 7] = points[1][1];\r\n//     vertices[index + 8] = points[1][2];\r\n//\r\n//     vertices[index + 9] = points[1][0];\r\n//     vertices[index + 10] = points[1][1];\r\n//     vertices[index + 11] = points[1][2];\r\n//     vertices[index + 12] = points[3][0];\r\n//     vertices[index + 13] = points[3][1];\r\n//     vertices[index + 14] = points[3][2];\r\n//     vertices[index + 15] = points[2][0];\r\n//     vertices[index + 16] = points[2][1];\r\n//     vertices[index + 17] = points[2][2];\r\n//\r\n//     for (i = 0; i < 18; i += 3) {\r\n//         colors[index + i] = color[0];\r\n//         colors[index + i + 1] = color[1];\r\n//         colors[index + i + 2] = color[2];\r\n//     }\r\n// }\r\n\r\nonmessage = function (event) {\r\n    var data = event.data;\r\n\r\n    postMessage(generateGreedyVoxelMesh(data.voxels, data.colorMap, data.chunkSize, data.voxelSize, data.offsets));\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/lib/helpers/voxelMeshGenerator.worker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}