"""
Cholesky with Side Information (CSI) learns low-rank kernel matrix approximation with respect ot regression targets or class labels.

    F. R. Bach and M. I. Jordan, "Predictive low-rank decomposition for kernel methods," Proceedings of the 22nd international conference on Machine learning - ICML 2005. ACM Press, New York, New York, USA, pp. 33-40, 2005.

Given a kernel matrix :math:`\mathbf{K} \in \mathbb{R}^{n\ x\ n}` and the targets :math:`\mathbf{y} \in \mathbb{R}^{n}`, find a low-rank approximation :math:`\mathbf{G} \in \mathbb{R}^{n\ x\ k}`.


.. math::
    \hat{\mathbf{K}} = \mathbf{G}\mathbf{G}^T

The implementation is based on the MATLAB/octave code provided by authors. It assumes an ``octave`` executable in the systems path and the ``oct2py`` Python module.

"""


import warnings
try:
    from oct2py import octave
except ImportError:
    warnings.warn("Install module 'oct2py' to use the CSI method.")
except OSError:
    warnings.warn("Set OCTAVE_EXECUTABLE to use the CSI method.")
from os.path import join, dirname, realpath
import numpy as np


class CSI:
    """
    :ivar G: (``numpy.ndarray``) Low-rank approximation.
    :ivar Q: (``numpy.ndarray``) QR decomposition of ``G`` (Q matrix).
    :ivar R: (``numpy.ndarray``) QR decomposition of ``G`` (R matrix).
    """

    def __init__(self, rank=40, kappa=0.99, centering=1, delta=40, eps=1e-20,):
        """
        :param rank: (``int``) Maximal decomposition rank.

        :param kappa: (``float``) Trade-off accuracy vs. predictive gain.

        :param centering: (``int``)  0 or 1, Centering of the kernel matrix.

        :param delta: (``int``) Number of look-ahead columns.

        :param eps: (``float``)  Tolerance lower bound.

        """
        self.rank      = rank
        self.delta     = delta
        self.kappa     = kappa
        self.centering = centering
        self.tol       = eps
        self.I         = list()
        self.active_set_ = list()
        self.trained   = False
        try:
            octave.addpath(join(dirname(realpath(__file__)), 'csi'))
        except NameError:
            raise NameError("Install module 'oct2py' to use the CSI method.")


    def fit(self, K, y):
        """Learn a low-rank kernel approximation.

        :param K: (``numpy.ndarray``) or of (``Kinterface``). The kernel to be approximated with G.

        :param y: (``numpy.ndarray``) Class labels :math:`y_i \in {-1, 1}` or regression targets.
        """

        # Convert to explicit form
        K = K[:, :]
        y = y.reshape((len(y), 1))

        # Call original implementation
        octave.push(["K", "y", "rank", "centering", "kappa", "delta", "tol"],
            [K, y, self.rank, self.centering, self.kappa, self.delta, self.tol])
        octave.eval("[G, P, Q, R, error1, error2, error, predicted_gain, true_gain] = csi(K, y, rank, centering, kappa, delta, tol)",
                    verbose=False)
        G, P, Q, R, error1, error2, error, predicted_gain, true_gain = \
            octave.pull(["G", "P", "Q", "R", "error1", "error2", "error", "predicted_gain", "true_gain"])
        R = np.atleast_2d(np.array(R))

        # Octave indexes from 1
        P = P.ravel().astype(int) - 1

        # Resort rows to respect the order
        n, k = K.shape[0], self.rank
        self.I = self.active_set_= list(P[:k])

        Go = np.zeros((n, k))
        Qo = np.zeros((n, k))
        Ro = np.zeros((k, k))
        km = min(k, G.shape[1])
        Go[P, :km] = G[:, :km]
        Qo[P, :km] = Q[:, :km]
        Ro[:km, :km] = R[:km, :km]
        self.G = Go[:, :self.rank]
        self.P = P[:self.rank]
        self.Q = Qo[:, :]
        self.R = Ro[:, :self.rank]
        self.error1 = error1
        self.error1 = error2
        self.error  = error
        self.predicted_gain = predicted_gain
        self.true_gain = true_gain
        self.trained = True
        self.active_set_ = self.I[:self.rank]


    def __call__(self, i, j):
        """
        Access portions of the combined kernel matrix at indices i, j.

        :param i: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :param j: (``int``) or (``numpy.ndarray``) Index/indices of data points(s).

        :return:  (``numpy.ndarray``) Value of the kernel matrix for i, j.
        """
        assert self.trained
        return self.G[i, :].dot(self.G[j, :].T)


    def __getitem__(self, item):
        """
        Access portions of the kernel matrix generated by ``kernel``.

        :param item: (``tuple``) pair of: indices or list of indices or (``numpy.ndarray``) or (``slice``) to address portions of the kernel matrix.

        :return:  (``numpy.ndarray``) Value of the kernel matrix for item.
        """
        assert self.trained
        return self.G[item[0], :].dot(self.G[item[1], :].T)

