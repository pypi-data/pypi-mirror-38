'''
Implement wallet logic following the formal wallet specification.
'''

from collections import namedtuple, deque
from recordclass import recordclass

# Basic Model.

Tx = namedtuple('Tx', 'txid inputs outputs')
TxIn = namedtuple('TxIn', 'txid ix')
TxOut = namedtuple('TxOut', 'addr c')
# UTxO :: Map TxIn TxOut
# Txs :: List Tx


def constraint_txins(txins, utxo):
    # More efficient than filter_ins
    return {txin: utxo[txin] for txin in txins if txin in utxo}


def exclude_txins_inplace(txins, utxo):
    # More efficient than filter_ins
    for txin in txins:
        utxo.pop(txin, None)
    return utxo


def balance(utxo):
    return sum(txout.c for txout in utxo.values())


def dom(utxo):
    return set(utxo.keys())


def txins(txs):
    'set of inputs spent by transactions'
    result = set()
    for tx in txs:
        result |= tx.inputs
    return result


def ours_txouts(txs, is_our_addr):
    'utxo generated by transactions which belongs to addresses.'
    return {TxIn(tx.txid, ix): txout
            for tx in txs
            for ix, txout in enumerate(tx.outputs)
            if is_our_addr(txout.addr)}


# Comment out current unused operations.
def txouts(txs):
    return {TxIn(tx.txid, ix): txout
            for tx in txs
            for ix, txout in enumerate(tx.outputs)}


def new_utxo(txs, is_our_addr):
    'new utxo added by these transactions and owned by addrs.'
    return exclude_txins_inplace(txins(txs), ours_txouts(txs, is_our_addr))


def dependent_on(tx2, tx1):
    'Check if tx2 is dependent on tx1'
    return any(lambda txin: txin.txid == tx1.txid, tx2.inputs)


Checkpoint = recordclass(
    'Checkpoint',
    'utxo expected_utxo pending utxo_balance')


class Wallet(object):
    def __init__(self, addrs):
        self.addrs = set(addrs)
        self.checkpoints = deque([Checkpoint({}, {}, [], 0)], maxlen=2160)

    def is_our_addr(self, addr):
        'check is our address'
        return addr in self.addrs

    def change(self, txs):
        'return change UTxOs from transactions.'
        return ours_txouts(txs, self.is_our_addr)

    def available_utxo(self):
        'available utxo'
        state = self.checkpoints[-1]
        utxo = state.utxo.copy()
        return exclude_txins_inplace(txins(state.pending), utxo)

    def total_utxo(self):
        'total utxo'
        change_utxo = self.change(self.checkpoints[-1].pending)
        return {**self.available_utxo(), **change_utxo}

    def available_balance(self):
        state = self.checkpoints[-1]
        spent_utxo = constraint_txins(txins(state.pending), state.utxo)
        return state.utxo_balance - balance(spent_utxo)

    def total_balance(self):
        change_utxo = self.change(self.checkpoints[-1].pending)
        return self.available_balance() + balance(change_utxo)

    def apply_block(self, txs):
        state = self.checkpoints[-1]

        txouts_ = ours_txouts(txs, self.is_our_addr)
        assert dom(txouts_) & dom(state.utxo) == set(), 'precondition doesn\'t meet'

        txins_ = txins(txs) & (dom(state.utxo) | dom(txouts_))
        self.apply_filtered_block(txins_, txouts_)

    def apply_filtered_block(self, txins_, txouts_):
        # add new utxo.
        state = self.checkpoints[-1]
        utxo = state.utxo.copy()
        utxo.update(txouts_)
        utxo_spent = constraint_txins(txins_, utxo)
        # remove spent utxo inplace.
        exclude_txins_inplace(txins_, utxo)
        utxo_balance = state.utxo_balance + balance(txouts_) - balance(utxo_spent)

        pending = filter(lambda tx: tx.inputs & txins_ == set, state.pending)

        new_utxo = exclude_txins_inplace(txins_, txouts_)
        expected_utxo = exclude_txins_inplace(dom(new_utxo), state.expected_utxo.copy())

        self.checkpoints.append(Checkpoint(utxo, expected_utxo, pending, utxo_balance))

    def new_pending(self, tx):
        assert tx.inputs.issubset(dom(self.available_utxo())), \
            'precondition doesn\'t meet.'
        self.checkpoints[-1].pending.append(tx)

    def rollback(self):
        assert self.checkpoints, 'no checkpoints, impossible.'
        if len(self.checkpoints) == 1:
            state = self.checkpoints[0]
            assert not state.pending and not state.utxo, 'impossible'
        else:
            old = self.checkpoints.pop()
            new = self.checkpoints[-1]
            new.pending += old.pending
            new.expected_utxo.update(old.expected_utxo)
            new.expected_utxo.update(exclude_txins_inplace(dom(new.utxo), old.utxo))

    # Invariants
    def invariant_3_4(self):
        state = self.checkpoints[-1]
        assert txins(state.pending).issubset(dom(state.utxo)), 'invariant broken'

    def invariant_3_5(self):
        result = all(self.is_our_addr(txout.addr)
                     for txout in self.checkpoints[-1].utxo.values())
        assert result, 'invariant broken'

    def invariant_3_6(self):
        change_utxo = self.change(self.checkpoints[-1].pending)
        assert dom(change_utxo) & dom(self.available_utxo()) == set(), 'invariant broken'

    def invariant_balance_cache(self):
        state = self.checkpoints[-1]
        assert state.utxo_balance == balance(state.utxo), \
            'balance cache broken.'
        assert self.available_balance() == balance(self.available_utxo()), \
            'balance is wrong'
        assert self.total_balance() == balance(self.total_utxo()), \
            'balance is wrong'

    def invariant_7_6(self):
        state = self.checkpoints[-1]
        assert dom(state.utxo) & dom(state.expected_utxo) == set(), 'invariant broken'

    def invariant_7_7(self):
        result = all(self.is_our_addr(txout.addr)
                     for txout in self.checkpoints[-1].expected_utxo.values())
        assert result, 'invariant broken'

    def invariant_7_8(self):
        state = self.checkpoints[-1]
        utxo = {**state.utxo, **state.expected_utxo}
        assert txins(state.pending).issubset(dom(utxo)), 'invariant broken'

    def check_invariants(self):
        invariants = [
            self.invariant_3_4,
            self.invariant_3_5,
            self.invariant_3_6,
            self.invariant_balance_cache,
            self.invariant_7_6,
            self.invariant_7_7,
            self.invariant_7_8,
        ]
        for inv in invariants:
            inv()


if __name__ == '__main__':
    # Test with local database.
    import random
    from .storage import Storage
    store = Storage('test_db', readonly=True)

    def random_addresses(threshold):
        addrs = set()
        for blk in store.blocks():
            for tx in blk.txs():
                for txout in tx.outputs:
                    if random.random() < 0.1:
                        addrs.add(txout.addr)
                        if len(addrs) > threshold:
                            return addrs

    print('Collect random addresses to test.')
    w = Wallet(random_addresses(10000))
    print('Apply blocks')
    b = w.available_balance()
    for blk in store.blocks():
        w.apply_block(blk.txs())
        w.check_invariants()
        n = w.available_balance()
        if n != b:
            b = n
            print('balance changed', b)
